'''
Created on 5 Mar 2010

@author: tcezard
'''
from IO_interface.exon_loader import Exon_annotation_Retriver
import utils
from IO_interface.annotation_loader import compare_exon_start
from utils.FastaFormat import FastaReader
from utils.Binning import Distribution_holder
import os
from overlap.Binnary_search_overlap import Binnary_search_overlap
from overlap import merge_ranges
from optparse import OptionParser
import logging
import sys
from utils import utils_logging


def calculateGC(sequence):
    count_G=sequence.count('G')
    count_C=sequence.count('C')
    return (count_G+count_C, float(count_G+count_C)/len(sequence))
    
def analyse_genome(genome_file, annotation_file, output_dir ):
    utils_logging.init_logging()
    
    reader=FastaReader(open(genome_file))
    exon_loader=Exon_annotation_Retriver(annotation_file=annotation_file)
    total_exon_coverage=0
    genome_length=0
    all_chr=exon_loader.get_chr_names()
    total_exon_number=0
    all_transcripts={}
    all_genes={}
    exon_sizes=Distribution_holder()
    gc_contents=Distribution_holder()
    all_gc_to_size={}
    all_size_to_gc={}
    
    for chr in all_chr:
        all_transcripts[chr]={}
        all_genes[chr]={}
    #for chr in all_chr:
    #    sequence='A'
    for header, sequence in reader:
        chr=header.strip()
        all_exons=exon_loader.get_annotation_from_chr(chr)
        if all_exons is None:
            logging.error('no exon for %s'%chr)
            continue
        all_exons.sort(cmp=compare_exon_start)
        curr_start=None
        curr_end=None
        exon_coverage=0
        exon_number=0
        for exon_infos in all_exons:
            (exon_start,exon_end,transcript_id,gene_id,
            transcript_start,transcript_end,cds_start,
            cds_end,chr,strand)=exon_infos
            exon_size=exon_end-exon_start+1
            exon_sizes.add_value(exon_size)
            gc_value,gc_fraction=calculateGC(sequence[exon_start-1:exon_end])
            gc=gc_fraction*100
            gc_contents.add_value(gc)
            size_dist= all_gc_to_size.get(int(gc))
            if size_dist is None:
                size_dist = Distribution_holder()
                all_gc_to_size[int(gc)]=size_dist
            size_dist.add_value(exon_size)
            
            gc_dist= all_size_to_gc.get(int(exon_size))
            if gc_dist is None:
                gc_dist = Distribution_holder()
                all_gc_to_size[int(exon_size)]=gc_dist
            gc_dist.add_value(gc)
            
            exon_number+=1
            all_transcripts[chr][transcript_id]=1
            all_genes[chr][gene_id]=1
            if curr_start is None and curr_end is None:
                curr_start=exon_start
                curr_end=exon_end
            else:
                if curr_end>=exon_start:
                    #overlap
                    if exon_end>curr_end:
                        curr_end=exon_end
                else:
                    #no overlap
                    exon_coverage+=curr_end-curr_start+1
                    curr_start=exon_start
                    curr_end=exon_end
        exon_coverage+=curr_end-curr_start+1
        out='%s\t%s\t%s\t%.1f%%\t%s genes \t%s transcripts \t%s exons'
        print out%(chr, len(sequence), exon_coverage, float(exon_coverage)/len(sequence)*100,
                   len(all_genes[chr]), len(all_transcripts[chr]), exon_number)
        total_exon_number+=exon_number
        total_exon_coverage+=exon_coverage
        genome_length+=len(sequence)
    
    print '%s\t%s\t%s\t%.1f%%'%(annotation_file, genome_length, total_exon_coverage, float(total_exon_coverage)/genome_length*100)
    sum_genes=0
    sum_transcript=0
    for chr in all_genes.keys():
        sum_genes+=len(all_genes[chr])
        sum_transcript+=len(all_transcripts[chr])
    print '%s genes \t%s transcripts \t%s exons'%(sum_genes, sum_transcript, total_exon_number)
    print 'mean exon size=%.2f +/- %.2f'%(exon_sizes.get_mean(),exon_sizes.get_std_dev())
    bins=range(0,1000,10)
    #exon_sizes.plot(bins=bins, output_file=os.path.join(plot_dir,'exon_sizes.png'), xlimit=[0,1000],xlabel='exon size', ylabel='exons')
    #gc_contents.plot(bins=100, output_file=os.path.join(plot_dir,'gc_content.png'), xlimit=[0,100],xlabel='%GC', ylabel='exons')
    exon_sizes.print_dist(output_file=os.path.join(output_dir,'exon_sizes.txt'))
    gc_contents.print_dist(output_file=os.path.join(output_dir,'gc_content.txt'))
    
    
def binary_search_in_array(array, value, compare_function):
    """Binary search in an array for a value which when applied the compare function return 0.
    The compare function take two arguments: the first is element of the array and the second is the given value.
    Assuming that the array is sorted, the compare function should return -1 if the value is located before in the array and +1 if the value is located after."""
    low = 0
    high = len(array) - 1
    lastMid=-1
    while low <= high:
        mid = (low + high) / 2
        res=compare_function(array[mid], value)
        if res==0:
            return mid
        else :
            if res < 0 :
                low = mid
            else :
                high = mid
        if lastMid==mid:
            break;
        lastMid=mid
    return None;


def read_exon_capture_file(exon_capture_file, extension=0):
    open_exon_capture=utils_logging.open_input_file(exon_capture_file, pipe=False)
    all_segments_per_chr={}
    for line in open_exon_capture:
        if line.startswith('#') or line.startswith('track'):
            #start of the bed_file
            if len(all_segments_per_chr)>0:
                logging.warning("Ignore second track of bed file %s"%exon_capture_file)
                return all_segments_per_chr
            #all_segments_per_chr={}
            continue
        sp_line=line.strip().split()
        chr=sp_line[0]
        start=int(sp_line[1])-extension+1
        end=int(sp_line[2])+extension
        all_segments=all_segments_per_chr.get(chr)
        if all_segments is None:
            all_segments=[]
            all_segments_per_chr[chr]=all_segments
        all_segments.append((start,end))
    open_exon_capture.close()
    return all_segments_per_chr

def get_length_of_list_range(array,end_inclusive=True):
    
    a=merge_ranges(array, end_inclusive)
    length=0
    for element in a:
        s=element[0]
        e=element[1]
        if end_inclusive:
            length+=e-s+1
        else:
            length+=e-s
    return length

def analyse_exon_capture_file(exon_capture_file, annotation_file, output_dir):
    exon_loader=Exon_annotation_Retriver(annotation_file=annotation_file)
    all_segments_per_chr=read_exon_capture_file(exon_capture_file)
    all_genes_with_probe={}
    all_transcripts_with_probe={}
    all_exons_with_probe={}
    all_genes={}
    all_transcripts={}
    all_exons={}
    probe_length_match=0
    probe_length_no_match=0
    probe_length=0
    nb_probe_with_no_match=0
    nb_probe_with_match=0
    total_exon_length=0
    total_exon_covered_length=0
    length_all_exons=0
    
    for chr in all_segments_per_chr.keys():
        probe_with_no_match={}
        probe_with_match={}
        exon_list=exon_loader.get_annotation_from_chr(chr)
        if exon_list is None:
            logging.error('No exon for %s'%chr)
            continue
        for exon in exon_list:
            (exon_start, exon_end, transcript_id, gene_id, dummy, dummy,
            dummy, dummy, chr, dummy)= exon
            all_genes[gene_id]=1
            all_transcripts[transcript_id]=1
            all_exons['%s\t%s\t%s\t%s'%(transcript_id,chr,exon_start,exon_end)]=(exon_start,exon_end)
        total_exon_length+=get_length_of_list_range(all_exons.values())
        all_segments=all_segments_per_chr.get(chr)
        probe_length+=get_length_of_list_range(all_segments)
        all_exons_search=Binnary_search_overlap(exon_list,sorted_query=True)
        
        for segment in all_segments:
            s2=segment[0]
            e2=segment[1]
            array_exon_with_ranges=all_exons_search.ovarlap_search(s2, e2)
            if array_exon_with_ranges is not None and len(array_exon_with_ranges)>0:
                for exon,list_ranges in array_exon_with_ranges:
                    (exon_start, exon_end, transcript_id, gene_id, dummy, dummy,
                    dummy, dummy, dummy, dummy)= exon
                    all_genes_with_probe[gene_id]=1
                    all_transcripts_with_probe[transcript_id]=1
                    key='%s\t%s\t%s\t%s'%(transcript_id,chr,exon_start,exon_end)
                    if all_exons_with_probe.has_key(key):
                        new_list_range=all_exons_with_probe.get(key)
                        new_list_range.extend(list_ranges)
                        list_ranges=merge_ranges(new_list_range)
                    all_exons_with_probe[key]=list_ranges
                probe_with_match['%s\t%s'%(s2,e2)]=(s2,e2,chr)
            else:
                probe_with_no_match['%s\t%s'%(s2,e2)]=(s2,e2,chr)
        
        probe_length_match+=get_length_of_list_range(probe_with_match.values())
        probe_length_no_match+=get_length_of_list_range(probe_with_no_match.values())
        nb_probe_with_match+=len(probe_with_match)
        nb_probe_with_no_match+=len(probe_with_no_match)
        all_exons_with_probe_str=all_exons_with_probe.keys()
        array_exon=[]
        for exon_str in all_exons_with_probe_str:
            transcript_id,chr,exon_start,exon_end=exon_str.split('\t')
            array_exon.append((int(exon_start), int(exon_end)))
        total_exon_covered_length+=get_length_of_list_range(array_exon)
        
    print "%s/%s (%.2f%%) genes have probes"%(len(all_genes_with_probe), len(all_genes), float(len(all_genes_with_probe))/len(all_genes)*100)
    print "%s/%s (%.2f%%) transcripts have probes"%(len(all_transcripts_with_probe), len(all_transcripts), float(len(all_transcripts_with_probe))/len(all_transcripts)*100 )
    print "%s/%s (%.2f%%) exons have probes"%(len(all_exons_with_probe), len(all_exons), float(len(all_exons_with_probe))/len(all_exons)*100 )
    print "%s probes with a match\t%s probes with no match"%(nb_probe_with_match,nb_probe_with_no_match)
    print "total probe length = %s, with match=%s, with no match=%s"%(probe_length,probe_length_match,probe_length_no_match)
    output_exon_missing=utils_logging.open_output_file(os.path.join(output_dir, 'exon_missing_probe.txt'),)
    exon_fraction=Distribution_holder()
    for exon_key in all_exons.keys():
        transcript_id,chr,exon_start,exon_end=exon_key.split('\t')
        exon_length=int(exon_end)-int(exon_start)+1
        list_ranges = all_exons_with_probe.get(exon_key)
        if list_ranges is not None:
            probe_length=get_length_of_list_range(list_ranges)
        else:
            probe_length=0
            output_exon_missing.write('%s\t%s\t%s\t%s\n'%(chr,exon_start,exon_end,transcript_id))
        fraction = probe_length/float(exon_length)
        if fraction>1.0:
            print 'error: %s is covered on more than its length: fraction=%s'%(exon_key,fraction)
        exon_fraction.add_value(fraction)
    print "%s/%s (%.2f%%) exon bases covered with probes"%(total_exon_covered_length, total_exon_length, float(total_exon_covered_length)/total_exon_length*100 )
    exon_fraction.print_dist(output_file=os.path.join(output_dir,'exon_fraction.txt'))
    output_exon_missing.close()
    output_probe_missing=utils_logging.open_output_file(os.path.join(output_dir, 'probe_missing_exon.txt'),)
    for probe_key in probe_with_no_match.keys():
        (s2,e2,chr)=probe_with_no_match.get(probe_key)
        output_probe_missing.write('%s\t%s\t%s\n'%(chr,s2,e2))
    output_probe_missing.close()


def analyse_exon_capture_file2(exon_capture_file, annotation_file, output_dir):
    exon_loader=Exon_annotation_Retriver(annotation_file=annotation_file)
    all_segments_per_chr=read_exon_capture_file(exon_capture_file)
    all_genes={}
    all_transcripts={}
    
    output_exons=os.path.join(output_dir, 'exon_list.txt')
    output_transcripts=os.path.join(output_dir, 'transcript_list.txt')
    output_genes=os.path.join(output_dir, 'gene_list.txt')
    open_exons=open(output_exons,'w')
    open_transcripts=open(output_transcripts,'w')
    open_genes=open(output_genes,'w')
    for chr in all_segments_per_chr.keys():
        print chr
        exon_list=exon_loader.get_annotation_from_chr(chr)
        if exon_list is None:
            logging.error('No exon for %s'%chr)
            continue
        all_segments=all_segments_per_chr.get(chr)
        all_segments_search=Binnary_search_overlap(all_segments,sorted_query=False)
        gene_to_exons={}
        transcript_to_exons={}
        for exon in exon_list:
            (exon_start,exon_end,transcript_id,gene_id,
            transcript_start,transcript_end,cds_start,
            cds_end,chr,strand)= exon
            if transcript_id == 'CCDS35278.1':
                print transcript_id, exon_start, exon_end
            
            all_genes[gene_id]=1
            all_transcripts[transcript_id]=1
            array_segment_with_ranges=all_segments_search.ovarlap_search(exon_start, exon_end)
            res_list_ranges=[]
            res_segments=[]
            for segment,list_ranges in array_segment_with_ranges:
                res_list_ranges.extend(list_ranges)
                res_segments.append(segment)
            res_list_ranges=merge_ranges(res_list_ranges)
            exon_length_overlap=get_length_of_list_range(res_list_ranges, end_inclusive=False)
            exon_length=exon_end-exon_start+1
            
            
            #Gather all the exon for that gene
            all_exons=gene_to_exons.get(gene_id)
            if all_exons is None:
                all_exons=[]
                gene_to_exons[gene_id]=all_exons
            all_exons.append((exon_start,exon_end,transcript_id,gene_id,
            transcript_start,transcript_end,cds_start,
            cds_end,chr,strand,res_list_ranges,res_segments))
            
            #Gather all the exons for that transcript
            all_exons = transcript_to_exons.get(transcript_id)
            if all_exons is None:
                all_exons=[]
                transcript_to_exons[transcript_id]=all_exons
            all_exons.append((exon_start,exon_end,transcript_id,gene_id,
            transcript_start,transcript_end,cds_start,
            cds_end,chr,strand,res_list_ranges,res_segments))
            
            out=[chr,str(exon_start),str(exon_end),transcript_id,gene_id,
                 str(transcript_start),str(transcript_end),str(cds_start),
                 str(cds_end),str(strand)]
            if len(res_segments)>0:
                out.append('%.3f'%(float(exon_length_overlap)/exon_length))
                out.append(str(res_segments))
            else:
                out.append('0')
                out.append('')
            #print '\t'.join(out)
            open_exons.write('\t'.join(out)+'\n')
            
        for transcript_id in transcript_to_exons.keys():
            all_exons=transcript_to_exons.get(transcript_id)
            res_list_ranges=[]
            res_segments=[]
            list_exon_range=[]
            for exon in all_exons:
                (exon_start, exon_end, transcript_id, gene_id,
                transcript_start, transcript_end, cds_start,
                cds_end,chr, strand, list_ranges, segments)=exon
                res_list_ranges.extend(list_ranges)
                res_segments.extend(segments)
                list_exon_range.append((exon_start,exon_end))
            
            transcript_length_overlap=get_length_of_list_range(res_list_ranges,end_inclusive=False)
            transcript_length=get_length_of_list_range(list_exon_range,end_inclusive=False)
            out=[chr,str(transcript_start),str(transcript_end),transcript_id,
                 gene_id,str(strand)]
            if len(res_segments)>0:
                out.append('%.5f'%(float(transcript_length_overlap)/transcript_length))
                out.append(str(merge_ranges(res_segments, end_inclusive=False)))
            else:
                out.append('0')
                out.append('')
            #print '\t'.join(out)
            open_transcripts.write('\t'.join(out)+'\n')
            
        for gene_id in gene_to_exons.keys():
            all_exons=gene_to_exons.get(gene_id)
            res_list_ranges=[]
            res_segments=[]
            list_exon_range=[]
            gene_start=9999999999999999
            gene_end=0
            for exon in all_exons:
                (exon_start, exon_end, transcript_id, gene_id,
                transcript_start, transcript_end, cds_start,
                cds_end,chr, strand, list_ranges, segments)=exon
                res_list_ranges.extend(list_ranges)
                res_segments.extend(segments)
                list_exon_range.append((exon_start,exon_end))
                if transcript_start<gene_start:
                    gene_start=transcript_start
                if transcript_end>gene_end:
                    gene_end=transcript_end
            
            gene_length_overlap=get_length_of_list_range(res_list_ranges,end_inclusive=False)
            gene_length=get_length_of_list_range(list_exon_range,end_inclusive=False)
            
            out=[chr,str(gene_start),str(gene_end),gene_id,str(strand)]
            if len(res_segments)>0:
                out.append('%.5f'%(float(gene_length_overlap)/gene_length))
                out.append(str(merge_ranges(res_segments, end_inclusive=False)))
            else:
                out.append('0')
                out.append('')
            #print '\t'.join(out)
            open_genes.write('\t'.join(out)+'\n')
    open_exons.close()
    open_transcripts.close()
    open_genes.close()


def main():
    #initialize the logging
    utils_logging.init_logging()
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    analyse_exon_capture_file(options.exon_capture_file, options.annotation_file, options.output_dir)
    analyse_exon_capture_file2(options.exon_capture_file, options.annotation_file, options.output_dir)
    if options.genome_file:
        analyse_genome(options.genome_file, options.annotation_file, options.output_dir)


def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-i input> <-o outputPath> [-q quality -f]"""
    description = """This script is a template to of a python script that include help and option's checking.
    The requirement and assumption of the script can be described here.
    A link to another documentation can also be added here."""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-a","--annotation_file",dest="annotation_file",type="string",
                         help="Path to a the file containing the annotation for that genome.. Default: %default")
    optparser.add_option("-e","--exon_capture_file",dest="exon_capture_file",type="string",
                         help="Path to a the file containing the exon-capture probe positions. Default: %default")
    optparser.add_option("-g","--genome_file",dest="genome_file",type="string",
                         help="Path to a the fasta file the genome. Default: %default")
    optparser.add_option("-o","--output_dir",dest="output_dir",type="string",
                         help="Path to a directory where the output file will be created. Default: %default")
    
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.annotation_file:
        logging.error("You must specify an annotation file.")
        arg_pass=False
    elif not os.path.exists(options.annotation_file):
        logging.error("%s does not exist: You must specify an existing annotation file."%options.annotation_file)
        arg_pass=False
        
    if not options.exon_capture_file:
        logging.error("You must specify an exon capture file.")
        arg_pass=False
    elif not os.path.exists(options.exon_capture_file):
        logging.error("%s does not exist: You must specify an existing exon capture file."%options.exon_capture_file)
        arg_pass=False
        
    if options.genome_file and not os.path.exists(options.genome_file):
        logging.error("%s does not exist: You must specify an existing genome file."%options.genome_file)
        arg_pass=False
        
    if not options.output_dir:
        logging.error("You must specify an output dir.")
        arg_pass=False
        
    return arg_pass



if __name__=="__main__":
    main()
    
if __name__=="1__main__":
    probe_file='/home/tcezard/projects/exons_capture_evaluation/agilent/source/SureSelect_All_Exon_G3362_with_names_hg19.bed'
    all_segments_per_chr=read_exon_capture_file(probe_file)
    probe_length=0
    for chr in all_segments_per_chr.keys():
        all_segments=all_segments_per_chr.get(chr)
        probe_length+=get_length_of_list_range(all_segments)
    print probe_length
    
    all_segments_per_chr=read_exon_capture_file(probe_file, extension=100)
    probe_length=0
    for chr in all_segments_per_chr.keys():
        all_segments=all_segments_per_chr.get(chr)
        probe_length+=get_length_of_list_range(all_segments)
    print probe_length

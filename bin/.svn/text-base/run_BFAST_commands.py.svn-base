'''
Created on 4 Feb 2010

@author: tcezard
'''
#!/usr/bin/env python
import os, sys, logging
from optparse import OptionParser
import glob
import utils
from utils import  utils_param, utils_logging
import command_runner

PREPARE_GENOME='prepare_genome'
PREPARE_READS='prepare_reads'
ALIGN_READS='align_reads'
RUN_TYPE=[PREPARE_GENOME,PREPARE_READS,ALIGN_READS]



def prepare_genome(genome_file,color_space=True):
    run_fine=True
    pipeline_param=utils_param.get_pipeline_parameters()
    BFAST_dir=pipeline_param.get_bfast_dir()
    BFAST_bin=os.path.join(BFAST_dir,'bin/bfast')
    if color_space:
        A='1'
    #Create a reference in color space
    command='%s fasta2brg -A %s -f %s'%(BFAST_bin, 1, genome_file)
    command_runner.run_command(command)
    #Create a reference in sequence space
    command='%s fasta2brg -A %s -f %s'%(BFAST_bin, 0, genome_file)
    #Create the indexes
    command_runner.run_command(command)
    #Try the recomended setting for human genome
    indexes=['1111111111111111111111',
             '111110100111110011111111111',
             '10111111011001100011111000111111',
             '1111111100101111000001100011111011',
             '111111110001111110011111111',
             '11111011010011000011000110011111111',
             '1111111111110011101111111',
             '111011000011111111001111011111',
             '1110110001011010011100101111101111',
             '111111001000110001011100110001100011111']
    for i,index in enumerate(indexes):
        command='%s index -A %s -f %s -m %s -w 14 -i %s'%(BFAST_bin, A, genome_file, index, i+1)
        command_runner.run_command(command)
    return run_fine
    

def prepare_run(genome_file, base_dir, sample_name=None, color_space=True):
    run_fine=True
    nb_read_per_file=10000000
    pipeline_param=utils_param.get_pipeline_parameters()
    BFAST_dir=pipeline_param.get_bfast_dir()
    if color_space:
        A='1'
    all_cs_fasta_compressed=glob.glob(os.path.join(base_dir,'*.csfasta.gz'))
    all_qual_compressed=glob.glob(os.path.join(base_dir,'*.qual.gz'))
    add_param='-z'
    if len(all_cs_fasta_compressed)==0 and len(all_qual_compressed)==0:
        all_cs_fasta=glob.glob(os.path.join(base_dir,'*.csfasta'))
        all_qual=glob.glob(os.path.join(base_dir,'*.qual'))
        add_param=''
    else:
        all_cs_fasta=all_cs_fasta_compressed
        all_qual=all_qual_compressed
    if len(all_cs_fasta)==0 or not utils.checkFiles(all_cs_fasta):
        logging.error("%s doesn't contain valid cs_fasta file"% base_dir)
        run_fine=False
    if len(all_qual)==0 or not utils.checkFiles(all_qual):
        logging.error("%s doesn't contain valid QV file"% base_dir)
        run_fine=False
        
    if run_fine: 
        tmp_dir=os.path.join(base_dir,'tmp')
        if sample_name is not None:
            fastq_name=os.path.join(tmp_dir,sample_name)
        else:
            fastq_name=os.path.join(tmp_dir,'reads')
        utils.createDirectories('', [tmp_dir])
        #Create the fastq file from the csfasta + qv file
        command='%s/scripts/solid2fastq -n %s -o %s %s %s %s'%(BFAST_dir, nb_read_per_file, fastq_name, add_param,' '.join(all_cs_fasta), ' '.join(all_qual))
        command_runner.run_command(command)
        
    return run_fine


def run_BFAST_Command(genome_file, base_dir, sample_name=None, color_space=True):
    run_fine=True
    pipeline_param=utils_param.get_pipeline_parameters()
    pipeline_param.get_bfast_dir()
    
    BFAST_dir=pipeline_param.get_bfast_dir()
    samtools_dir=pipeline_param.get_samtools_dir()
    
    BFAST_bin=os.path.join(BFAST_dir,'bin/bfast')
    samtools_bin=os.path.join(samtools_dir,'samtools')
    if color_space:
        A='1'
    
    tmp_dir=os.path.join(base_dir,'tmp')
    if not os.path.exists(tmp_dir):
        logging.error("%s doesn't exist. Run %s type to create it"%(tmp_dir,PREPARE_READS))
        run_fine=False
    fastq_files=glob.glob(os.path.join(tmp_dir,'*.fastq'))
    if len(fastq_files)==0:
        logging.error("%s doesn't contain fastq files. Run %s type to create it"%(tmp_dir,PREPARE_READS))
        run_fine=False
    else:
        # Match the sequence to the
        
        for fastq_file in fastq_files:
            tmp, ext=os.path.splitext(fastq_file)
            fastq_name=os.path.basename(tmp)
            return_code=0
            if return_code==0:
                bmf_file='%s.bmf'%os.path.join(tmp_dir,fastq_name)
                command='%s match -f %s -A %s -r %s -T %s/ > %s'%(BFAST_bin, genome_file, A, fastq_file, tmp_dir,  bmf_file)
                return_code=command_runner.run_command(command)
            if return_code==0:
                #Perform local alignment
                baf_file='%s.baf'%os.path.join(tmp_dir,fastq_name)
                command='%s localalign -f %s -m %s -A %s > %s'%(BFAST_bin, genome_file, bmf_file, A, baf_file)
                return_code=command_runner.run_command(command)
            
            if return_code==0:
                #Filter Alignment and output sam
                sam_file='%s.sam'%os.path.join(tmp_dir,fastq_name)
                command='%s postprocess -f %s -i %s -a 4 -O 1 > %s'%(BFAST_bin, genome_file, baf_file, sam_file)
                return_code=command_runner.run_command(command)
            if return_code==0:
                #Alignment complete. Transform into bam and sort
                bam_file='%s_sorted'%os.path.join(tmp_dir,fastq_name)
                command='%s view -bT %s %s | %s sort - %s '%(samtools_bin,genome_file,sam_file,samtools_bin,bam_file)
                return_code=command_runner.run_command(command)
                
            if return_code==0:
                command='rm -vf %s %s %s'%(bmf_file,baf_file,sam_file)
                return_code=command_runner.run_command(command)
            if return_code!=0:
                run_fine=False
    return run_fine
        

def main():
    #initialize the logging
    utils_logging.init_logging()
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    if options.print_out:
        utils_logging.change_log_stdout_to_log_stderr()
    else:
        command_runner.set_command_to_run_localy()
    
    run_fine=True
    run_types=options.run_type.split(',')
    if PREPARE_GENOME in run_types:
        run_fine=prepare_genome(options.genome_file, options.color_space)
    if PREPARE_READS in run_types and run_fine:
        run_fine=prepare_run(options.genome_file, options.base_dir, options.sample_name, options.color_space)
    if ALIGN_READS in run_types and run_fine:
        run_fine=run_BFAST_Command(options.genome_file, options.base_dir, options.sample_name, options.color_space)
    
    if run_fine:
        logging.info('Run completed')
        
def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-g genome_fasta> <-b base_directory> [-t run_type]"""
    description = """"""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-g","--genome_file",dest="genome_file",type="string",
                         help="Path to a fasta file where the genome is located. Default: %default")
    optparser.add_option("-b","--base_dir",dest="base_dir",type="string",
                         help="Path to a the base directory where the reads are and the results will be output. The csfasta and QV files must be in that directory. Default: %default")
    optparser.add_option("-t","--run_type",dest="run_type",type="string",default=ALIGN_READS,
                         help="The type of possible run (can be \""+'", "'.join(RUN_TYPE)+"\"). Default: %default")
    optparser.add_option("-n","--sample_name",dest="sample_name",type="string",
                         help="The name of the sample currently being aligned. Default: %default")
    optparser.add_option("-c","--color_space",dest="color_space",action='store_false',default=True,
                         help="Set the type of read to sequence space. Default: %default")
    optparser.add_option("--print",dest="print_out",action='store_true',default=False,
                         help="Set the the script to print the commands instead of running them. Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.genome_file :
        logging.error("You must specify a genome fasta file.")
        arg_pass=False
    elif not os.path.exists(options.genome_file):
        logging.error("Genome fasta file not found. You must specify an existing genome fasta file.")
        arg_pass=False
    if not options.base_dir:
        logging.error("You must specify a base directory.")
        arg_pass=False
    elif not os.path.exists(options.base_dir):
        logging.error("Base dir not found. You must specify an existing directory.")
        arg_pass=False
    
    if not options.run_type:
        logging.error("You must specify a run type.")
        arg_pass=False
    else:
        run_types=options.run_type.split(',')
        for type in run_types:
            if type not in RUN_TYPE:
                logging.error("%s not in valid run type. You must specify a run type from %s"%(type,' '.join(RUN_TYPE)))
                arg_pass=False
    return arg_pass



if __name__=="__main__":
    main()
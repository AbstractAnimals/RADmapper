'''
Created on Mar 9, 2011

@author: tcezard
'''
import re
from utils import utils_logging
from IO_interface import vcfIO
import sys,logging,string
import pprint
import itertools
import operator
from optparse import OptionParser
import os
from collections import Counter, defaultdict

OUTPUT_TYPE_JOINMAP="joinmap"
OUTPUT_TYPE_CARTHAGENE="carthagene"

OUTPUT_TYPE=[OUTPUT_TYPE_JOINMAP,OUTPUT_TYPE_CARTHAGENE]
def generate_empty_hash_with_sample(all_samples):
    hash={}
    for sample in all_samples:
        hash[sample]={}
    hash['all']={}
    return hash

def count_with_hash(hashtable, key):
    if hashtable.has_key(key):
        hashtable[key]+=1
    else:
        hashtable[key]=1
        
def get_offsprings_possible_genotypes_jm():
    #the parents pattern assume that the mother is first and the father second
    jm_parents_pattern={"0/1 0/0":{"type":"<lmxll>", "0/0":"ll", "0/1":"lm", "1/0":"lm"},
                        "0/1 1/1":{"type":"<lmxll>", "1/1":"ll", "0/1":"lm", "1/0":"lm"},
                        "0/0 0/1":{"type":"<nnxnp>", "0/0":"nn", "0/1":"np", "1/0":"np"},
                        "1/1 0/1":{"type":"<nnxnp>", "1/1":"nn", "0/1":"np", "1/0":"np"},
                        "0/1 0/1":{"type":"<hkxhk>", "0/0":"hh", "0/1":"hk", "1/0":"hk", "1/1":"kk"},
                        "0/1 0/2":{"type":"<efxeg>", "0/0":"ee", "0/1":"ef", "0/2":"eg", "1/2":"fg"},
                        "0/1 1/2":{"type":"<efxeg>", "1/1":"ee", "0/1":"ef", "0/2":"eg", "1/2":"fg"},
                        "0/2 0/1":{"type":"<efxeg>", "0/0":"ee", "0/1":"eg", "0/2":"ef", "1/2":"fg"},
                        "0/2 1/2":{"type":"<efxeg>", "0/0":"ee", "0/1":"eg", "0/2":"ef", "1/2":"fg"},
                        "0/1 2/3":{"type":"<abxcd>", "0/2":"ac", "0/3":"ad", "1/2":"bc", "1/3":"bd"},
                        "0/2 1/3":{"type":"<abxcd>", "0/1":"ac", "0/3":"ad", "1/2":"bc", "2/3":"bd"},
                        "0/3 1/2":{"type":"<abxcd>", "0/1":"ac", "0/2":"ad", "1/3":"bc", "2/3":"bd"},
                        "1/2 0/3":{"type":"<abxcd>", "0/1":"ac", "1/3":"ad", "0/2":"bc", "2/3":"bd"},
                        "1/3 0/2":{"type":"<abxcd>", "0/1":"ac", "0/2":"ad", "0/3":"bc", "2/3":"bd"},
                        "2/3 0/1":{"type":"<abxcd>", "0/2":"ac", "1/2":"ad", "0/3":"bc", "1/3":"bd"},
#"0/0 1/1":{},
#"0/0 1/2":{},
#"1/1 0/0":{},
#"1/2 0/0":{},
                        }
    
    
    
    
    return jm_parents_pattern

def get_offsprings_possible_genotypes_ca():
    #the parents pattern assume that the mother is first and the father second
    ca_pattern1={"0/0":"A", "0/1":"H"}
    ca_pattern_rev1={"1/1":"A", "0/1":"H"}
    
    
    ca_parents_pattern={"0/0 0/1":{"0/0":"A", "0/1":"H"},
                        "0/1 0/0":{"0/0":"A", "0/1":"H"},
                        "0/1 1/1":{"1/1":"A", "0/1":"H"},
                        "1/1 0/1":{"1/1":"A", "0/1":"H"},
                        "0/1 0/1":{"0/0":"H", "0/1":"-", "1/1":"A"}
                        }
    
    jm_parents_pattern={"0/1 0/0":{"0/0":"ll", "0/1":"lm", "1/0":"lm"},
                        "0/1 1/1":{"1/1":"ll", "0/1":"lm", "1/0":"lm"},
                        "0/0 0/1":{"0/0":"nn", "0/1":"np", "1/0":"np"},
                        "1/1 0/1":{"1/1":"nn", "0/1":"np", "1/0":"np"},
                        
                        "0/1 0/1":{"0/0":"hh", "0/1":"hk", "1/0":"hk", "1/1":"kk"},
                        "0/1 0/2":{"0/0":"ee", "0/1":"ef", "0/2":"eg", "1/2":"fg"},
                        "0/1 1/2":{"1/1":"ee", "0/1":"ef", "0/2":"eg", "1/2":"fg"},
                        "0/2 0/1":{"0/0":"ee", "0/1":"eg", "0/2":"ef", "1/2":"fg"},
                        "0/2 1/2":{"0/0":"ee", "0/1":"eg", "0/2":"ef", "1/2":"fg"},
                        "0/1 2/3":{"0/2":"ac", "0/3":"ad", "1/2":"bc", "1/3":"bd"},
                        "0/2 1/3":{"type":"<abxcd>", "0/1":"ac", "0/3":"ad", "1/2":"bc", "2/3":"bd"},
                        "0/3 1/2":{"type":"<abxcd>", "0/1":"ac", "0/2":"ad", "1/3":"bc", "2/3":"bd"},
                        "1/2 0/3":{"type":"<abxcd>", "0/1":"ac", "1/3":"ad", "0/2":"bc", "2/3":"bd"},
                        "1/3 0/2":{"type":"<abxcd>", "0/1":"ac", "0/2":"ad", "0/3":"bc", "2/3":"bd"},
                        "2/3 0/1":{"type":"<abxcd>", "0/2":"ac", "1/2":"ad", "0/3":"bc", "1/3":"bd"}
                        }
    
    return ca_parents_pattern
    
    


def load_sex_info(file):
    sample_to_sex={}
    sex_to_sample={}
    sex_to_sample["M"]=[]
    sex_to_sample["F"]=[]
    open_file = utils_logging.open_input_file(file, pipe=False)
    for line in open_file:
        sp_line = line.strip().split()
        if sp_line[1]=="m" or sp_line[1]=="M":
            sex_to_sample["M"].append(sp_line[0])
            sample_to_sex[sp_line[0]]="M"
        elif sp_line[1]=="f" or sp_line[1]=="F":
            sex_to_sample["F"].append(sp_line[0])
            sample_to_sex[sp_line[0]]="F"
        
    open_file.close()
    return sample_to_sex,sex_to_sample

def reverse_consensus(consensus):
    tmp=[]
    for letter in consensus:
        if letter=='A':
            tmp.append('H')
        elif letter=='H':
            tmp.append('A')
        else:
            tmp.append(letter)
    return "".join(tmp)


def snps_to_carthagene(vcf_file, sex_info, mother, father, geno_qual_threshold, 
                       output_male_markers, output_female_markers, output_vcf,
                       merge_locus=False):
    sample_to_sex, sex_to_sample = load_sex_info(sex_info)
    file_handle = utils_logging.open_input_file(vcf_file, pipe=False)
    open_output = utils_logging.open_output_file(output_vcf, pipe=False) 
    reader  = vcfIO.VcfReader(file_handle)
    reader.get_header_lines()
    open_output.write(reader.get_header_lines()+'\n')
    ordered_sample=[]
    for sample in reader.get_sample_names():
        ordered_sample.append(sample)
    ordered_sample.remove(mother)
    ordered_sample.remove(father)
    if merge_locus:
        process_locus = process_and_merge_marker_of_a_locus
    else:
        process_locus = process_marker_of_a_locus
    
    possible_genotypes=get_offsprings_possible_genotypes_ca()
    uninformative_markers=0
    discard_quality_parent=0
    bad_pattern=0
    inconsistent_locus=0
    all_markers_male={}
    all_markers_female={}
    curr_reference=None
    curr_set_markers=defaultdict(list)
    uninformative_marker_type=Counter()
    for vcf_record in reader:
        #First check that the parent are callable
        geno_mother = vcf_record.get_genotype(mother)
        gq_mother = vcf_record.get_genotype_quality(mother)
        geno_father = vcf_record.get_genotype(father)
        gq_father = vcf_record.get_genotype_quality(father)
        
        if gq_mother < geno_qual_threshold or gq_father < geno_qual_threshold:
            discard_quality_parent+=1
            continue
        parent_pattern = "%s %s"%(geno_mother,geno_father)
        
        offspring_genotypes = possible_genotypes.get(parent_pattern)
        if not offspring_genotypes:
            uninformative_markers+=1
            uninformative_marker_type[parent_pattern]+=1
            continue 
        all_sample_out=[]
        skip_marker=False
        
        for sample in ordered_sample:
            g = vcf_record.get_valid_genotype_per_sample(genotype_quality_threshold=10,
                                                          minimum_depth=6,sample_list=[sample])
            if len(g)>0:
                geno=g.keys()[0]
                result = offspring_genotypes.get(geno)
                if result:
                    all_sample_out.append(result)
                else:
                    t="mother:%s and father:%s offspring:%s (%s - %s) at marker:%s:%s"
                    
                    logging.warning(t%(geno_mother,geno_father,geno, sample, sample_to_sex.get(sample),
                                       vcf_record.get_reference(), vcf_record.get_position()))
                    skip_marker=True
                    all_sample_out.append("X")
            else:
                all_sample_out.append("-")
        #print vcf_records.get_reference(),"".join(all_sample_out)
        
        if skip_marker:
            bad_pattern+=1
            continue
#        print vcf_record.get_reference(), curr_reference

        if vcf_record.get_reference() !=curr_reference and curr_reference:
            (curr_set_markers, curr_reference, all_markers_male, all_markers_female)
            if not process_locus(curr_set_markers, curr_reference, 
                                      all_markers_male, all_markers_female):
                inconsistent_locus+=1
            curr_reference = vcf_record.get_reference()
            curr_set_markers=defaultdict(list)
            
        pattern_offspring="".join(all_sample_out)
        curr_set_markers[parent_pattern].append((pattern_offspring, vcf_record))
        curr_reference = vcf_record.get_reference()
        open_output.write(str(vcf_record)+'\n')
    open_output.close()
    
    if not process_locus(curr_set_markers, curr_reference, all_markers_male, all_markers_female):
        inconsistent_locus+=1
    
    
    print "%s discarded because of quality issue in parents"%discard_quality_parent
    print "%s discarded because uninformative (%s)"%(uninformative_markers, " -- ".join(['%s:%s'%(key,value) for key,value in uninformative_marker_type.items()]))
    print "%s discarded because of bad pattern"%bad_pattern
    print "%s discarded because of locus is inconsistent"%inconsistent_locus
    
    output_carthagene_markers(sample_to_sex, ordered_sample, output_male_markers, output_female_markers, all_markers_male, all_markers_female)

def output_carthagene_markers(sample_to_sex, ordered_sample, output_male_markers, output_female_markers, all_markers_male, all_markers_female):
    key1="".join([sample_to_sex.get(sample).replace("F","A").replace("M","H") for sample in ordered_sample])
    key2="".join([sample_to_sex.get(sample).replace("M","A").replace("F","H") for sample in ordered_sample])
    #add_to_array_in_dictionnary(all_markers_male, key1, "sex")
    #add_to_array_in_dictionnary(all_markers_male, key2, "sex_rev")
    #add_to_array_in_dictionnary(all_markers_female, key1, "sex")
    #add_to_array_in_dictionnary(all_markers_female, key2, "sex_rev")
    male_out = utils_logging.open_output_file(output_male_markers)
    #male_markers_out = utils_logging.open_output_file(output_male_markers+'.markers')
    male_out.write("data type f2 backcross\n")
    nb_marker=2
    for list_marker in all_markers_male.values():
        nb_marker+=len(list_marker)
    male_out.write("%s %s 0 0 0\n"%(len(ordered_sample),nb_marker))
    male_out.write("*sex\t%s\n"%(key1))
    male_out.write("*sex_rev\t%s\n"%(key2))
    for marker_name in all_markers_male.pop(key1,[]):
        male_out.write("*%s\t%s\n"%(marker_name, key1))
    for marker_name in all_markers_male.pop(key2,[]):
        male_out.write("*%s\t%s\n"%(marker_name, key2))
    for offspring_pattern in all_markers_male.keys():
        for marker_name in all_markers_male.get(offspring_pattern):
            male_out.write("*%s\t%s\n"%(marker_name, offspring_pattern))
        
    male_out.close()
    
    female_out = utils_logging.open_output_file(output_female_markers)
    #female_markers_out = utils_logging.open_output_file(output_female_markers+'.markers')
    nb_marker=2
    for list_marker in all_markers_female.values():
        nb_marker+=len(list_marker)
    female_out.write("data type f2 backcross\n")
    female_out.write("%s %s 0 0 0\n"%(len(ordered_sample),nb_marker))
    female_out.write("*sex\t%s\n"%(key1))
    female_out.write("*sex_rev\t%s\n"%(key2))
    for marker_name in all_markers_female.pop(key1,[]):
        female_out.write("*%s\t%s\n"%(marker_name, key1))
    for marker_name in all_markers_female.pop(key2,[]):
        female_out.write("*%s\t%s\n"%(marker_name, key2))
    for offspring_pattern in all_markers_female.keys():
        for marker_name in all_markers_female.get(offspring_pattern):
            female_out.write("*%s\t%s\n"%(marker_name, offspring_pattern))
        
    female_out.close()
    
        
def process_and_merge_marker_of_a_locus(curr_set_markers, curr_reference, all_markers_male, all_markers_female):
    """This function will collapse the SNPs of a same locus into one marker.
    This require to put the SNPs in the same phase first then both phase are added."""
    
    markers=[]
    markers.extend(curr_set_markers.get("0/0 0/1",[]))
    markers.extend(curr_set_markers.get("1/1 0/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/1",[]))
    consensus_male=None
    consensus_female=None
    markers=[offspring_pattern for offspring_pattern,vcf_record in markers]
    if len(markers)>0:
        consensus_male = collapse_set_of_markers(markers)
    markers=[]
    markers.extend(curr_set_markers.get("0/1 1/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/0",[]))
    markers=[offspring_pattern for offspring_pattern,vcf_record in markers]
    if len(markers)>0:
        consensus_female = collapse_set_of_markers(markers)
    
    if consensus_male is None or 'Y' in consensus_male or consensus_female is None or 'Y' in consensus_female:
        if consensus_male and 'Y' in consensus_male:
            logging.warning("found inconsistent call in %s --> %s"%(curr_reference,consensus_male))
        if consensus_female and 'Y' in consensus_female:
            logging.warning("found inconsistent call in %s --> %s"%(curr_reference,consensus_female))
        process_marker_of_a_locus(curr_set_markers, curr_reference, all_markers_male, all_markers_female)
    else:
        ref_name = curr_reference.split('_')[1]
        add_to_array_in_dictionnary(all_markers_male, consensus_male,"cs%s"%(ref_name))
        add_to_array_in_dictionnary(all_markers_male, reverse_consensus(consensus_male),"cs%s_rev"%(ref_name))
        add_to_array_in_dictionnary(all_markers_female, consensus_female,"cs%s"%(ref_name))
        add_to_array_in_dictionnary(all_markers_female, reverse_consensus(consensus_female),"cs%s_rev"%(ref_name))
    return True

def process_marker_of_a_locus(curr_set_markers, curr_reference, all_markers_male, all_markers_female):
    """"""
    markers=[]
    markers.extend(curr_set_markers.get("0/0 0/1",[]))
    markers.extend(curr_set_markers.get("1/1 0/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/1",[]))
    for marker_info in markers:
        offspring_pattern, vcf_record=marker_info
        ref_name = vcf_record.get_reference().split('_')[1]
        marker_name='cs%s:%s'%(ref_name, vcf_record.get_position())
        add_to_array_in_dictionnary(all_markers_male, offspring_pattern,"%s"%(marker_name))
        add_to_array_in_dictionnary(all_markers_male, reverse_consensus(offspring_pattern),"%s_rev"%(marker_name))
    markers=[]
    markers.extend(curr_set_markers.get("0/1 1/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/1",[]))
    markers.extend(curr_set_markers.get("0/1 0/0",[]))
    for marker_info in markers:
        offspring_pattern, vcf_record=marker_info
        ref_name = vcf_record.get_reference().split('_')[1]
        marker_name='cs%s:%s'%(ref_name, vcf_record.get_position())
        #all_markers_female[marker_name]=offspring_pattern
        #all_markers_female[marker_name+"_rev"]=reverse_consensus(offspring_pattern)
        add_to_array_in_dictionnary(all_markers_female, offspring_pattern,"%s"%(marker_name))
        add_to_array_in_dictionnary(all_markers_female, reverse_consensus(offspring_pattern),"%s_rev"%(marker_name))
    return True

def phase_of(marker1,marker2):
    #remove the unknown genotype position
    start=0
    tmp1=marker1
    tmp2=marker2
    while tmp1.find("-",start)>0:
        start=tmp1.find("-",start)
        tmp1=tmp1[:start]+tmp1[start+1:]
        tmp2=tmp2[:start]+tmp2[start+1:]
    start=0
    while tmp2.find("-",start)>0:
        start=tmp2.find("-",start)
        tmp1=tmp1[:start]+tmp1[start+1:]
        tmp2=tmp2[:start]+tmp2[start+1:]
    
    if tmp1==tmp2:
        return True
    elif tmp1.translate(string.maketrans("AH","HA"))==tmp2:
        return False
    else:
        return None    
    
def dephase_markers(all_markers):
    all_new_markers=[]
    for marker in all_markers:
        all_new_markers.append(marker)
        
    for i in range(0,len(all_new_markers)-1):
        for j in range(i+1,len(all_new_markers)):
            phase = phase_of(all_new_markers[i], all_new_markers[j])
            #print phase
            if phase is None:
                pass
            elif phase:
                pass
            else:
                #print "change %s (%s --> %s)"%(j, all_markers[j] ,all_markers[j].translate(string.maketrans("AH","HA")))
                all_new_markers[j]=all_new_markers[j].translate(string.maketrans("AH","HA"))
    return all_new_markers
    
def collapse_set_of_markers(all_markers):
    consensus=[]
    if len(all_markers)>0:
        #print "marker before dephasing "
        #for m in all_markers:print m
        all_markers=dephase_markers(all_markers)
        #print "marker after dephasing  "
        #for m in all_markers:print m
        nb_individuals=len(all_markers[0])
        for i in range(nb_individuals):
            consensus_call='-'
            for marker in all_markers:
                if consensus_call=='-':
                    consensus_call=marker[i]
                elif marker[i]=='-':
                    pass
                elif consensus_call==marker[i]:
                    continue
                elif consensus_call!=marker[i]:
                    consensus_call='Y'
                    break
            consensus.append(consensus_call)
    return "".join(consensus)

def snps_to_joinmap(vcf_file, sex_info, mother, father, geno_qual_threshold, 
                       output_markers, output_vcf):
    sample_to_sex, sex_to_sample = load_sex_info(sex_info)
    file_handle = utils_logging.open_input_file(vcf_file, pipe=False)
    open_output = utils_logging.open_output_file(output_vcf, pipe=False)
    open_marker = utils_logging.open_output_file(output_markers, pipe=False)
    reader  = vcfIO.VcfReader(file_handle)
    reader.get_header_lines()
    open_output.write(reader.get_header_lines()+'\n')
    ordered_sample=[]
    for sample in reader.get_sample_names():
        ordered_sample.append(sample)
    ordered_sample.remove(mother)
    ordered_sample.remove(father)
    
    possible_genotypes=get_offsprings_possible_genotypes_jm()
    uninformative_markers=0
    discard_quality_parent=0
    bad_pattern=0
    inconsistent_locus=0
    
    for vcf_records in reader:
        #First check that the parent are callable
        geno_mother = vcf_records.get_genotype(mother)
        gq_mother = vcf_records.get_genotype_quality(mother)
        geno_father = vcf_records.get_genotype(father)
        gq_father = vcf_records.get_genotype_quality(father)
        
        if gq_mother < 20 or gq_father < 20:
            discard_quality_parent+=1
            continue
        parent_pattern = "%s %s"%(geno_mother,geno_father)
        alleles_mother=set(geno_mother.split('/'))
        alleles_father=set(geno_father.split('/'))
        offspring_genotypes = possible_genotypes.get(parent_pattern)
        if not offspring_genotypes:
            uninformative_markers+=1
            continue 
        all_sample_out=[]
        bad_offsprings=0
        
        for sample in ordered_sample:
            g = vcf_records.get_valid_genotype_per_sample(genotype_quality_threshold=geno_qual_threshold,
                                                          minimum_depth=6,sample_list=[sample])
            if len(g)>0:
                geno=g.keys()[0]
                result = offspring_genotypes.get(geno)
                if result:
                    all_sample_out.append(result)
                else:
                    alleles_offspring=set(geno.split('/'))
                    if len(alleles_offspring.intersection(alleles_mother))==0:
                        e="missing maternal allele"
                    elif len(alleles_offspring.intersection(alleles_father))==0:
                        e="missing paternal allele"
                    else:
                        e=""
                    t="mother:%s and father:%s offspring:%s (%s - %s) at marker:%s:%s --> %s"
                    
                    logging.warning(t%(geno_mother,geno_father,geno, sample, sample_to_sex.get(sample),
                                       vcf_records.get_reference(), vcf_records.get_position(),e))
                    bad_offsprings+=1
                    all_sample_out.append("--")
            else:
                all_sample_out.append("--")
        #print vcf_records.get_reference(),"".join(all_sample_out)
        
        if bad_offsprings>1:
            bad_pattern+=1
            continue
        open_marker.write("%s:%s\t%s\t%s\n"%(vcf_records.get_reference(), vcf_records.get_position(), possible_genotypes.get(parent_pattern).get('type'),  ' '.join(all_sample_out)))
        open_output.write(str(vcf_records)+'\n')
    open_output.close()
    open_marker.close()
   
    
    print "%s discarded because of quality issue in parents"%discard_quality_parent
    print "%s discarded because uninformative"%uninformative_markers
    print "%s discarded because of bad pattern"%bad_pattern
    print "%s discarded because of locus is inconsistent"%inconsistent_locus


class Phased_vcf_reader():
    def __init__(self, vcf_file, mother, father, geno_qual_threshold):
        
        self.file_handle = utils_logging.open_input_file(vcf_file, pipe=False)
        self.reader  = vcfIO.VcfReader(self.file_handle)
        self.geno_qual_threshold=geno_qual_threshold
        self.mother=mother
        self.father=father
        self.nb_snps=0
        self.marker_created=0
        self.discard_quality_parent=0
        self.ordered_sample=[]
        for sample in self.reader.get_sample_names():
            self.ordered_sample.append(sample)
        self.ordered_sample.remove(self.mother)
        self.ordered_sample.remove(self.father)
        
    def read(self):
        
        end_of_phase=False
        phased_genotype_mother=[]
        phased_genotype_father=[]
        phased_vcf_record=[]
        previous_reference=None
        start_session_mother=False
        start_session_father=False
        
        for vcf_records in self.reader:
            #First check that the parent are callable
            self.nb_snps+=1
            discarded_snp=False
            geno_mother = vcf_records.get_genotype(self.mother)
            gq_mother = vcf_records.get_genotype_quality(self.mother)
            geno_father = vcf_records.get_genotype(self.father)
            gq_father = vcf_records.get_genotype_quality(self.father)
            if gq_mother < self.geno_qual_threshold or gq_father < self.geno_qual_threshold:
                self.discard_quality_parent+=1
                discarded_snp=True
                self.marker_created+=1
                #break the Phase if we the quality in the parent is bad
                #do not add this SNP
                add_SNP_before=False
                add_SNP_after=False
                end_of_phase=True
            elif vcf_records.is_phased_with_previous(sample=self.mother) and vcf_records.is_phased_with_previous(sample=self.father):
                #Keep the Phase if both parents are keeping the phase
                #Add this SNP to the phased set
                add_SNP_before=True
                add_SNP_after=False
                end_of_phase=False
                
            else:
                #Break the Phase if at least one parent is breaking the phase
                #Add this SNP to a new phased set
                add_SNP_before=False
                add_SNP_after=True
                #to correctly phase homozygous location at the beginning of contigs 
                if not vcf_records.is_phased_with_previous(sample=self.mother):
                    start_session_mother=True
                if not vcf_records.is_phased_with_previous(sample=self.father):
                    start_session_father=True
                if start_session_mother and start_session_father:
                    end_of_phase=True
                else:
                    end_of_phase=False
                
            
            
            if previous_reference and previous_reference!=vcf_records.get_reference():
                #break the Phase if we change reference
                add_SNP_before=False
                if not discarded_snp:
                    add_SNP_after=True
                end_of_phase=True
                start_session_mother=start_session_father=False
            
            if vcf_records.get_info_tag_value('PhasingInconsistent'):
                #break the phase if GATK says the phasing is inconsistent
                end_of_phase=True
                
            if add_SNP_before:
                phased_genotype_mother.append(re.split(r'[|/]',geno_mother))
                phased_genotype_father.append(re.split(r'[|/]',geno_father))
                phased_vcf_record.append(vcf_records)
            #print previous_reference, vcf_records.get_reference() , vcf_records.get_position()
            #print 'in phase for mother=%s, in phase for father=%s, end_of_phase=%s, add_SNP_before=%s, add_SNP_after=%s'%(
            #                                                         vcf_records.is_phased_with_previous(sample=self.mother),
            #                                                         vcf_records.is_phased_with_previous(sample=self.father),
            #                                                         end_of_phase, add_SNP_before,add_SNP_after)
            #print 'start_session_mother=%s, start_session_father=%s'%(start_session_mother,start_session_father)
            #print 'nb_of SNPs in phased set = %s'%len(phased_vcf_record)
            #if  len(phased_vcf_record)>0:
            #    print ' || '.join(['%s--%s'%(tmp.get_reference(),tmp.get_position()) for tmp in phased_vcf_record])
            if end_of_phase and len(phased_vcf_record)>0:
                self.marker_created+=1
                yield(phased_genotype_mother, phased_genotype_father, phased_vcf_record)
                
                phased_genotype_mother=[]
                phased_genotype_father=[]
                phased_vcf_record=[]    
                
            if add_SNP_after:
                phased_genotype_mother.append(re.split(r'[|/]',geno_mother))
                phased_genotype_father.append(re.split(r'[|/]',geno_father))
                phased_vcf_record.append(vcf_records)
            previous_reference = vcf_records.get_reference()
        if len(phased_vcf_record)>0:
            self.marker_created+=1
            yield(phased_genotype_mother, phased_genotype_father, phased_vcf_record)
            
            
    def get_ordered_samples(self):
        return self.ordered_sample
    
    def get_nb_marker_created(self):
        return self.marker_created
    
    def get_discard_quality_parent(self):
        return self.discard_quality_parent
    
    def get_nb_snps(self):
        return self.nb_snps
    
def phased_snps_to_joinmap(vcf_file, sex_info, mother, father, geno_qual_threshold, output_markers, output_vcf, max_missing_offspring):
    sample_to_sex, sex_to_sample = load_sex_info(sex_info)
    #open_output = utils_logging.open_output_file(output_vcf, pipe=False)
    open_marker = utils_logging.open_output_file(output_markers, pipe=False)
    possible_genotypes=get_offsprings_possible_genotypes_jm()
    phased_reader = Phased_vcf_reader(vcf_file, mother, father, geno_qual_threshold)
    ordered_sample = phased_reader.get_ordered_samples()
    uninformative_markers=0
    bad_pattern=0
    for phased_genotype_mother, phased_genotype_father, phased_vcf_record in phased_reader.read():
        
   
        geno_parents, all_offsprings_genotypes = process_genotypes_of_a_locus(phased_genotype_mother,
                                                                            phased_genotype_father,
                                                                            phased_vcf_record,ordered_sample,
                                                                            max_missing_offspring=max_missing_offspring)
        if all_offsprings_genotypes is None:
            bad_pattern+=1
            continue
        name = get_list_of_SNPs_name(phased_vcf_record)
        out = output_marker(name, possible_genotypes, ordered_sample, geno_parents, all_offsprings_genotypes)
        if out is None:
            uninformative_markers+=1
        else: 
            open_marker.write(out)
    open_marker.close()
    print '%s marker created by phasing %s SNPs'%(phased_reader.get_nb_marker_created(), phased_reader.get_nb_snps())
    print "%s discarded because of quality issue in parents"%phased_reader.get_discard_quality_parent()
    print "%s discarded because uninformative"%uninformative_markers
    print "%s discarded because of bad pattern"%bad_pattern


def output_marker(name,possible_genotypes, ordered_samples, geno_parents, all_offsprings_genotypes):
    possible_offspring_genotypes = possible_genotypes.get(geno_parents)
    uninformative_markers=False
    if not possible_offspring_genotypes:
        uninformative_markers=True
        return 
    all_sample_out=[]
    bad_offsprings=0
    
    for i,sample in enumerate(ordered_samples):
        geno=all_offsprings_genotypes[i]
        result = possible_offspring_genotypes.get(geno)
        if result:
            all_sample_out.append(result)
        else:
            all_sample_out.append("--")
    #print vcf_records.get_reference(),"".join(all_sample_out)
    return "%s\t%s\t%s\n"%(name, possible_genotypes.get(geno_parents).get('type'),  ' '.join(all_sample_out))

    
def process_genotypes_of_a_locus(phased_genotype_mother,phased_genotype_father,
                                 phased_vcf_record, samples,
                                 genotype_quality_threshold=20,
                                 max_missing_offspring=5):
    #get the parents haplotypes
    set_parents_haplotypes = {}
    hm1,hm2 = merge_phased_genotype(phased_genotype_mother)
    set_parents_haplotypes[hm1]=1
    if set_parents_haplotypes.has_key(hm2):set_parents_haplotypes[hm2]+=1
    else:set_parents_haplotypes[hm2]=1
    hf1,hf2 = merge_phased_genotype(phased_genotype_father)
    if set_parents_haplotypes.has_key(hf1):set_parents_haplotypes[hf1]+=1
    else:set_parents_haplotypes[hf1]=1
    if set_parents_haplotypes.has_key(hf2):set_parents_haplotypes[hf2]+=1
    else:set_parents_haplotypes[hf2]=1
    #sort the haplotype by the most frequent in the parent so most frequent is called 0 and second most frequent is 1 and so on
    sorted_set = sorted(set_parents_haplotypes.iteritems(), key=operator.itemgetter(1), reverse=True)
    list_parents_haplotypes = [key for key, value in sorted_set]
    parents_haplotypes={}
    i=0
    for hap in list_parents_haplotypes:
        parents_haplotypes[hap]=i
        i+=1
    genotype_mother=[str(parents_haplotypes.get(hm1)),str(parents_haplotypes.get(hm2))]
    genotype_mother.sort()
    genotype_father=[str(parents_haplotypes.get(hf1)),str(parents_haplotypes.get(hf2))]
    genotype_father.sort()
    all_offspring_genotype_high_qual=get_genotype_for_list_of_SNPs(list_vcf_record=phased_vcf_record,
                                                                  samples=samples, 
                                                                  genotype_quality_threshold=genotype_quality_threshold)
    missing_offspring=0
    all_samples_genotypes=[]
    for i in range(len(samples)):
        haplo_off1,haplo_off2=merge_phased_genotype(all_offspring_genotype_high_qual[i])
        allele1 = parents_haplotypes.get(haplo_off1)
        allele2 = parents_haplotypes.get(haplo_off2)
        m_haplo_off1=m_haplo_off2='-'*len(haplo_off1)
        if allele1 is None or allele2 is None:
            m_haplo_off1, m_haplo_off2 = match_haplotypes_to_parents(list_parents_haplotypes, haplo_off1, haplo_off2)
            allele1 = parents_haplotypes.get(m_haplo_off1)
            allele2 = parents_haplotypes.get(m_haplo_off2)
        if allele1 is None or allele2 is None: 
            missing_offspring+=1
        if allele1 is None: allele1='.'
        if allele2 is None: allele2='.'
        genotype_offspring=[str(allele1),str(allele2)]
        genotype_offspring.sort()
        all_samples_genotypes.append('/'.join(genotype_offspring))
    geno_parents='%s %s'%('/'.join(genotype_mother),'/'.join(genotype_father))
    if missing_offspring>max_missing_offspring:
        all_samples_genotypes=None
    return geno_parents,all_samples_genotypes
        
def match_haplotypes_to_parents(list_parents_haplotypes, ho1, ho2, max_difference=10):
    """This method take two haplotypes from an offspring and match them against the parental haplotypes.
    @return the matching parental haplotypes of None if the haplotype wasn't found."""
    def check_one_haplotype(all_results, h1, h2):
        res=hamming1(h1,h2)
        if all_results.has_key(res):
            all_results[res].append(h1)
        else:
            all_results[res]=[h1]
    ret1=ret2=None
    all_results_1={}
    #print 'parent haplotypes = %s'%(' '.join(list_parents_haplotypes))
    for haplotype in list_parents_haplotypes:
        check_one_haplotype(all_results_1, haplotype, ho1)
    scores = all_results_1.keys()
    scores.sort(reverse=False)
    #print '%s --> best score =%s (%s)'%(ho1,scores[0],', '.join([str(val) for val in scores]))
    if len(all_results_1.get(scores[0]))==1 and scores[0]<max_difference:
        ret1=all_results_1.get(scores[0])[0]
    else:
        ret1=ho1
    all_results_2={}
    for haplotype in list_parents_haplotypes:
        check_one_haplotype(all_results_2, haplotype, ho2)
    scores = all_results_2.keys()
    scores.sort(reverse=False)
    #print '%s --> best score =%s (%s)'%(ho2,scores[0],', '.join([str(val) for val in scores]))
    if len(all_results_2.get(scores[0]))==1 and scores[0]<max_difference:
        ret2=all_results_2.get(scores[0])[0]
    else:
        ret2=ho2
    return ret1,ret2


def hamming1(str1, str2):
    return sum(itertools.imap(not_equal, str1, str2))
    #return sum(itertools.imap(str.__ne__, str1, str2))
    
def not_equal(str1,str2):
    if str1=='.':
        return 1
    elif str2=='.':
        return 1
    elif str1==str2:
        return 0
    else:
        return 50
    
def get_genotype_for_list_of_SNPs(list_vcf_record, samples, genotype_quality_threshold=0):
    all_samples_genotype=[]
    for sample in samples:
        all_samples_genotype.append([])
        
    for vcf_record in list_vcf_record:
        genotypes=vcf_record.get_all_genotype(sample_list=samples)
        genotype_qualities=vcf_record.get_all_genotype_quality(sample_list=samples)
        for i in range(len(samples)):
            if int(genotype_qualities[i])>genotype_quality_threshold:
                all_samples_genotype[i].append(re.split(r'[|/]',genotypes[i]))
            else:
                all_samples_genotype[i].append(['.','.'])
    return all_samples_genotype


def get_list_of_SNPs_name(list_vcf_record):
    ref=None
    positions=[]
    for vcf_record in list_vcf_record:
        if ref and ref!=vcf_record.get_reference():
            logging.error("%s and %s are different: can only get a name to SNPs of the same reference"%(ref,vcf_record.get_reference()))
            return None
        else:
            ref=vcf_record.get_reference()
        positions.append(str(vcf_record.get_position()))
    return '%s:%s'%(ref,'_'.join(positions))
    
        
def merge_phased_genotype(phased_genotype):
    first = []
    second = []
    for f,s in phased_genotype:
        first.append(f)
        second.append(s)
    return ''.join(first), ''.join(second)


def add_to_array_in_dictionnary(dict,key,value):       
    array = dict.get(key)
    if not array:
        array=[]
        dict[key]=array
    array.append(value)
        
def snps_to_pattern(vcf_file, sex_info, mother, father, geno_qual_threshold):
    sample_to_sex, sex_to_sample = load_sex_info(sex_info)
    file_handle = utils_logging.open_input_file(vcf_file, pipe=False)
    reader  = vcfIO.VcfReader(file_handle)
    sample_names = reader.get_sample_names()
    discard_quality_parent=0
    for vcf_records in reader:
        #First check that the parent are callable
        geno_mother = vcf_records.get_genotype(mother)
        gq_mother = vcf_records.get_genotype_quality(mother)
        geno_father = vcf_records.get_genotype(father)
        gq_father = vcf_records.get_genotype_quality(father)
        if gq_mother < geno_qual_threshold or gq_father < geno_qual_threshold:
            discard_quality_parent+=1
            continue
        #print "%s %s"%(geno_mother,geno_father)
        all_sample_out=[]
        sum=0
        if "%s %s"%(geno_mother,geno_father) == "0/1 0/1":
            continue
        for male_sample in sex_to_sample.get("M"):
            g = vcf_records.get_valid_genotype_per_sample(genotype_quality_threshold=10,
                                                          minimum_depth=6,sample_list=[male_sample])
            if len(g)>0:
                geno=g.keys()[0]
                if geno==geno_father:
                    all_sample_out.append("1")
                    sum+=1
                else:
                    all_sample_out.append("0")
            else:
                all_sample_out.append("-")
        for female_sample in sex_to_sample.get("F"):
            g = vcf_records.get_valid_genotype_per_sample(genotype_quality_threshold=10,
                                                          minimum_depth=6,sample_list=[female_sample])
            if len(g)>0:
                geno=g.keys()[0]
                if geno==geno_mother:
                    all_sample_out.append("1")
                    sum+=1
                else:
                    all_sample_out.append("0")
            else:
                all_sample_out.append("-")
        
        print vcf_records.get_reference(),"".join(all_sample_out)+" %s"%sum
        
            


def filter_alleles(sample_to_allele):
    all_alleles_count = sample_to_allele.pop('all')
    total=0.0
    valid_alleles=[]
    for alleles in all_alleles_count:
        total+=all_alleles_count.get(alleles)
    for allele in all_alleles_count:
        if all_alleles_count.get(allele)>1 and all_alleles_count.get(allele)/total>0.05:
            valid_alleles.append(allele)
    for sample in sample_to_allele.keys():
        test_alleles = sample_to_allele.get(sample)
        total=0.0
        for alleles in test_alleles:
            total+=test_alleles.get(alleles)
        for allele in test_alleles.keys():
            if not allele in valid_alleles or test_alleles.get(allele)==1 or test_alleles.get(allele)/total<=0.05 :
                test_alleles.pop(allele)

def detect_missing_allele(vcf_file, normalization_factors):
    file_handle = utils_logging.open_input_file(vcf_file, pipe=False)
    reader  = vcfIO.VcfReader(file_handle)
    reader.get_header_lines()
    mother="MP"
    father="FP"
    for vcf_recors in reader:
        d_mo = vcf_recors.get_sample_depth(mother)
        d_fa = vcf_recors.get_sample_depth(father)
        norm_mother = float(d_mo)/normalization_factors.get(mother)
        norm_father = float(d_fa)/normalization_factors.get(father)
        print norm_mother,norm_father, vcf_recors.get_reference(), vcf_recors.get_position()
    

def main():
    #initialize the logging
    utils_logging.init_logging()
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    if options.type_output==OUTPUT_TYPE_JOINMAP:
        phased_snps_to_joinmap(options.input_vcf_file, options.sex_info_file, options.mother_name, 
                               options.father_name, geno_qual_threshold=options.geno_qual_threshold,
                               output_markers=options.output_marker, output_vcf=None, max_missing_offspring=options.max_missing_offspring)
    elif options.type_output==OUTPUT_TYPE_CARTHAGENE:
        snps_to_carthagene(options.input_vcf_file, options.sex_info_file, options.mother_name, 
                           options.father_name, geno_qual_threshold=options.geno_qual_threshold,
                           output_male_markers=options.output_male_marker, output_female_markers=options.output_female_marker, 
                           output_vcf=options.output_vcf)
    
    
def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog -i <input_vcf_file> -s <sex_info_file> -m <mother_name> -f <father_name> -o <output_markers> [-g 20]"""
    description = """This script ."""
    
    optparser = OptionParser(description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-i","--input_vcf_file",dest="input_vcf_file",type="string",
                         help="Path to input vcf file where the SNPs are located. Default: %default")
    optparser.add_option("-s","--sex_info_file",dest="sex_info_file",type="string",
                         help="""Path to sex information file where the name and sex of the samples is specified in tab separated format.
The format is: name<tab>M/F.
Default: %default""")
    optparser.add_option("-m","--mother_name",dest="mother_name",type="string",
                         help="The name of the mother. Default: %default")
    optparser.add_option("-f","--father_name",dest="father_name",type="string",
                         help="The name of the father. Default: %default")
    optparser.add_option("-g","--geno_qual_threshold",dest="geno_qual_threshold",type="int",default =20,
                         help="the genotype quality threshold above which genotypes will be used. Default: %default")
    optparser.add_option("-o","--output_marker",dest="output_marker",type="string",
                         help="Path to the file that will contain the markers. Default: %default")
    optparser.add_option("-p","--output_male_marker",dest="output_male_marker",type="string",
                         help="Path to the file that will contain the males markers. Default: %default")
    optparser.add_option("-q","--output_female_marker",dest="output_female_marker",type="string",
                         help="Path to the file that will contain the female markers. Default: %default")
    optparser.add_option("-v","--output_vcf",dest="output_vcf",type="string",
                         help="Path to the file that will contain the SNPs retained in VCF format. Default: %default")
    optparser.add_option("-x","--max_missing_offspring",dest="max_missing_offspring",type="int",
                         help="the maximum of missing offspring allow before a marker get removed. Offspring can be missing because the genotype is imprecise of because of a mendelian error. Default: %default")
    optparser.add_option("-t","--type_output",dest="type_output",type="string",default=OUTPUT_TYPE_JOINMAP,
                         help="Type of output format required. (Should be one of "+ ", ".join(OUTPUT_TYPE)+") Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.input_vcf_file or not os.path.exists(options.input_vcf_file):
        logging.error("You must specify a valid input file.")
        arg_pass=False
    if not options.sex_info_file or not os.path.exists(options.sex_info_file):
        logging.error("You must specify a valid sex information file.")
        arg_pass=False
    if not options.mother_name:
        logging.error("You must specify the name of the mother.")
        arg_pass=False
    if not options.father_name:
        logging.error("You must specify the name of the father.")
        arg_pass=False
    if not options.type_output in OUTPUT_TYPE:
        logging.error("You must specify a valid output type (%s)."%", ".join(OUTPUT_TYPE))
    elif options.type_output == OUTPUT_TYPE_JOINMAP and not options.output_marker:
        logging.error("You must specify an output file with -o for joinmap format output.")
        arg_pass=False
    elif options.type_output == OUTPUT_TYPE_CARTHAGENE:
        if not options.output_male_marker:
            logging.error("You must specify a male output file with -p for carthagene format output.")
            arg_pass=False
        if not options.output_male_marker:
            logging.error("You must specify a female output file with -q for carthagene format output.")
            arg_pass=False
    return arg_pass


if __name__=="__main__":
    main()


if __name__=="1__main__":
    """"""
    utils_logging.init_logging()
    vcf_file = sys.argv[1]
    sex_info_file = sys.argv[2]
    mother=sys.argv[3]
    father=sys.argv[4]
    output_file=sys.argv[5]
    output_vcf=sys.argv[6]
    if len(sys.argv)>7:
        output_genoqual=int(sys.argv[7])
    else:
        output_genoqual=20
    snps_to_joinmap(vcf_file, sex_info_file, mother, father, geno_qual_threshold=output_genoqual, output_markers=output_file,
                    output_vcf=output_vcf)
    
    
    
if __name__=="1__main__":
    """"""
    utils_logging.init_logging()
    vcf_file = sys.argv[1]
    sex_info_file = sys.argv[2]
    mother=sys.argv[3]
    father=sys.argv[4]
    output_file=sys.argv[5]
    output_vcf=sys.argv[6]
    if len(sys.argv)>7:
        output_genoqual=int(sys.argv[7])
    else:
        output_genoqual=20
    phased_snps_to_joinmap(vcf_file, sex_info_file, mother, father, geno_qual_threshold=output_genoqual,
                           output_markers=output_file, output_vcf=output_vcf)
    
    
if __name__=="1__main__":
    """"""
    utils_logging.init_logging()
    vcf_file = sys.argv[1]
    sex_info_file = sys.argv[2]
    mother=sys.argv[3]
    father=sys.argv[4]
    male_output_file=sys.argv[5]
    female_output_file=sys.argv[6]
    output_vcf=sys.argv[7]
    
    snps_to_carthagene(vcf_file, sex_info_file, mother, father, 20,
                       male_output_file, female_output_file, output_vcf)
if __name__=="1__main__":
    vcf_file=sys.argv[1]
    normalization_factors={"MP":1,"FP":1.1194}
    detect_missing_allele(vcf_file, normalization_factors=normalization_factors)

'''
Created on 27 Jul 2010

@author: tcezard
'''
import os
from get_data_from_seqarchive import get_files_from_seq_archive,\
    find_files_in_seq_archive, get_link_from_seq_archive
import command_runner
from utils import utils_logging, utils_commands, createDirectories
import logging
from wiki_communication.wiki_exceptions import Wiki_Parser_Error
from utils.utils_commands import shellize_file_name,\
    get_output_stream_from_command
import utils
import sys
from optparse import OptionParser
from wiki_communication.wiki_pages_utils import get_run_page_from_title,\
    get_all_run_page_titles
import threading
import glob
from utils.utils_param import get_pipeline_parameters
import time


def find_run_data(run_page_title, output_dir):
    log_file_name = os.path.join(output_dir,shellize_file_name(run_page_title)+'.txt')
    createDirectories(output_dir, ['error','warning','fine'])
    utils_logging.init_logging(output_level=None, log_file_name=log_file_name, overwrite=True)
    try :
        run_page=get_run_page_from_title(run_page_title)
        if not run_page:
            raise Wiki_Parser_Error('No run page for title %s'%(run_page_title))
        dest_dir='/home/tcezard/temp/'
        for run_element in run_page.run.get_lanes():
            server_and_paths = find_files_in_seq_archive(run_element)
            if server_and_paths:
                
                logging.info('found %s for run %s'%(' '.join(['%s:%s'%s for s in server_and_paths]),run_element.id))
            else:
                logging.error('Cannot find file for run %s'%(run_element.id))
    except Wiki_Parser_Error, e:
        #logging.error('%s on %s'%(str(e), run_page_title))
        pass
    utils_logging.remove_logging_file_handler(log_file_name)
    error=False
    warning=False
    if os.path.isfile(log_file_name):
        open_file=open(log_file_name)
        for line in open_file:
            if line.startswith('ERROR'):
                error=True
            elif line.startswith('WARNING'):
                warning=True
        open_file.close()
        
        if error:
            command='mv -f %s %s/error/'%(log_file_name, output_dir)
            logging.info(command)
            utils_commands.launchCommandLocally(command)
        elif warning:
            command='mv -f %s %s/warning/'%(log_file_name, output_dir)
            logging.info(command)
            utils_commands.launchCommandLocally(command)
        else:
            command='mv -f %s %s/fine/'%(log_file_name, output_dir)
            logging.info(command)
            utils_commands.launchCommandLocally(command)
        #fastq_files=get_files_from_seq_archive(run_element, dest_dir, overwrite=True)
        #print fastq_files
        #for fastq_file in fastq_files:
            #analyze_fastq(fastq_file)
            
        
def run_all_quality_check(output_dir, overwrite, check):
    all_page_parents_and_titles = get_all_run_page_titles(type='SOLEXA')
    options_to_add=[]
    if overwrite:
        options_to_add.append('--force')
    if check:
        options_to_add.append('-c')
    for parent_page_title, run_page_title in all_page_parents_and_titles:
        if run_page_title.startswith('08') or run_page_title.startswith('09'):
            continue
        command='python %s -r "%s" -o %s %s'%(sys.argv[0],run_page_title, output_dir, ' '.join(options_to_add))
        print command

class Threaded_fastq_analysis(threading.Thread):
    
    def __init__(self,run_element, run_dir, overwrite, analyze_fastq, is_index=False):
        self.run_element=run_element
        self.run_dir=run_dir
        self.overwrite=overwrite
        self.analyze_fastq = analyze_fastq
        self.is_index=is_index
        threading.Thread.__init__ ( self )
        
    def run(self):
        if not QC_results_exist(self.run_dir, self.run_element.id, self.run_element.get_run().is_single_end(),self.is_index):
            server_and_paths = find_files_in_seq_archive(self.run_element)
            if server_and_paths:
                #logging.info('found %s for run %s'%(' '.join(paths),self.run_element.id))
                fastq_files=get_link_from_seq_archive(self.run_element, self.run_dir, overwrite=self.overwrite)
                for fastq_file in fastq_files:
                    fastq_file = self.analyze_fastq(fastq=fastq_file, output_dir=self.run_dir)
                    command= 'rm -f %s'%fastq_file
                    command_runner.run_command(command)
            else:
                logging.error('Cannot find file for run %s'%(self.run_element.id))
                

def run_quality_check(output_dir, run_page_title, overwrite=False, no_thread=False, index_only=False):
    run_dir=os.path.join(output_dir,shellize_file_name(run_page_title))
    #if os.path.exists(run_dir) and not overwrite:
    #    logging.info('run %s has been QC already: pass QC'%(run_page_title))
    #    return 
    utils.createDirectories('',[run_dir])
    log_file_name = os.path.join(run_dir,shellize_file_name(run_page_title)+'.txt')
    utils_logging.init_logging(output_level=None, log_file_name=log_file_name, overwrite=overwrite)
    
    try :
        run_page=get_run_page_from_title(run_page_title)
    except Wiki_Parser_Error, e:
        run_page=None
        logging.error('%s on %s'%(str(e), run_page_title))
        return 
    finally:
        utils_logging.remove_logging_file_handler(log_file_name)
    if not index_only:
        all_threads=[]
        for run_element in run_page.run.get_lanes():
            print run_element
            try:
                thread = Threaded_fastq_analysis(run_element, run_dir, overwrite,
                                                 analyze_fastq=analyze_lane_fastq, is_index=False)
                all_threads.append(thread)
                if no_thread:
                    thread.run()
                else:
                    thread.start()
                    time.sleep(2)
            except StandardError:
                logging.exception('CRASH')
        for thread in all_threads:
            thread.join()
    if run_page.run.is_indexed():
        all_threads=[]
        for run_element in run_page.run.get_run_elements():
            print run_element
            try:
                thread = Threaded_fastq_analysis(run_element, run_dir, overwrite,
                                                 analyze_fastq=analyze_indexed_fastq, is_index=True)
                all_threads.append(thread)
                if no_thread:
                    thread.run()
                else:
                    thread.start()
                    time.sleep(2)
            except StandardError:
                logging.exception('CRASH')
        for thread in all_threads:
            thread.join()
    try:
        load_qc_in_run_page(run_dir, run_page)
        logging.info('upload run page to wiki')
        url, report = run_page.upload_to_wiki(test_wiki=False)
        logging.info('Uploaded to %s'%url)
        logging.info(report)
        
    except StandardError:
        logging.exception('CRASH')
    utils_logging.remove_logging_file_handler(log_file_name)

def run_adapter_trimming(output_dir, run_page_title, overwrite=False):
    try :
        run_page=get_run_page_from_title(run_page_title)
    except Wiki_Parser_Error, e:
        run_page=None
        logging.error('%s on %s'%(str(e), run_page_title))
        return 
    for run_element in run_page.run.get_lanes():
        print run_element
        try:
            server_and_paths = find_files_in_seq_archive(run_element)
            if server_and_paths:
                fastq_files=get_files_from_seq_archive(run_element, run_dir, overwrite=overwrite)
                for fastq_file in fastq_files:
                    command = ''%fastq_file
        except StandardError:
            logging.exception('CRASH')

        
def QC_results_exist(run_dir, run_element, single_end, index=False):
    return_value=True
    if single_end:
        names=[run_element]
    else:
        names=[run_element+'_1',
               run_element+'_2']
    if index:
        index_files =os.path.join(run_dir,'index.stats')
        for name in names:
            command = "grep '%s' %s"%(name,index_files)
            output, process= get_output_stream_from_command(command)
            line=None
            for line in output.readline():
                if len(line.split())>1:
                    break
            if not line:
                return_value=False
    else:
        #qc_files = ['_base_distrib.qv',
        #           '.solfastq.png',
        #           '_distrib.qv',
        #           '.solfastq.quality',
        #           '_good_quality_len_distribution.qv',
        #           '.solfastq.quality.pdf',
        #           '_mean_median.qv',
        #           '.solfastq.segments',
        #           '.solfastq.matrix',
        #           '.solfastq.segments.hist.pdf']
        qc_files = ['_fastqc',
                    '.solfastq.png',
                    '.solfastq.quality',
                    '.solfastq.quality.pdf',
                    '.solfastq.segments',
                    '.solfastq.matrix',
                    '.solfastq.segments.hist.pdf']
        for name in names:
            path = os.path.join(run_dir,name)
            for qc_file in qc_files:
                if not os.path.exists(path + qc_file):
                    logging.info("can't find %s"%(path + qc_file))
                    return_value=False
                    break
    return return_value
 

def analyze_lane_fastq(fastq, output_dir):
    pipeline_tools=get_pipeline_parameters()
    solexaqa_bin = os.path.join(pipeline_tools.get_solexaqa_dir(),'SolexaQA.pl')
    matrix2png_dir = pipeline_tools.get_matrix2png_dir()
    fastqc_bin = os.path.join(pipeline_tools.get_fastqc_dir(),'fastqc')
    os.environ['PATH']=os.environ['PATH']+':%s'%(matrix2png_dir)
    name, ext = os.path.splitext(fastq)
    if ext=='.gz':
        command = 'gunzip -f %s'%fastq
        command_runner.run_command(command)
        fastq=name
    name, ext = os.path.splitext(fastq)
    if ext==".sanfastq":
        command = 'perl %s -sanger %s'%(solexaqa_bin, fastq)
    else:
        command = 'perl %s -illumina %s'%(solexaqa_bin, fastq)
        
    os.chdir(output_dir)
    command_runner.run_command(command)
    
    command = '%s %s'%(fastqc_bin, fastq)
    command_runner.run_command(command)
    command = 'mv -f %s.so_fastqc %s_fastqc'%(name, name)
    command_runner.run_command(command)
    command = 'rm %s.so_fastqc.zip'%(name)
    command_runner.run_command(command)
    
    logging.info('done analysing %s'%fastq)
    return fastq


def analyze_indexed_fastq(fastq, output_dir):
    name, ext = os.path.splitext(fastq)
    if ext=='.gz':
        name, ext = os.path.splitext(os.path.basename(name))
    else:
        name = os.path.basename(name)
    logging.info( 'analyse %s'%(fastq))
    if fastq.endswith('.gz'):
        command = "gunzip -c %s | wc -l | awk '{print $1/4}'"%(fastq)
    else:
        command = "cat -c %s | wc -l | awk '{print $1/4}'"%(fastq)
    logging.info(command)
    output,process = get_output_stream_from_command(command)
    nb_read=''
    for line in output:
        if line:
            nb_read = int(line)
    open_index_stat = open(os.path.join(output_dir,'index.stats'), 'a')
    open_index_stat.write('%s\t%s\n'%(name, nb_read))
    open_index_stat.close()
    return fastq


def get_run_quality_dir2(run_element):
    run_dir='/home/tcezard/temp/run_quality_data/'+shellize_file_name(run_element.get_run().get_run_page_title())
    return run_dir


def get_qc_from_seq_archive(run_quality_dir, run_element, is_single_end):
    """Temporary function to get the QC"""
    nb_read=None
    nb_good_qual_read1=None
    qual_tile_png1=None
    nb_good_qual_read2 = None
    qual_tile_png2 = None
    if os.path.exists(run_quality_dir):
        if is_single_end:
            path_template = os.path.join(run_quality_dir, run_element.id)
            nb_read,nb_good_qual_read1,qual_tile_png1  = tmp_get_qc_res2(path_template)
            nb_good_qual_read2 = None
            qual_tile_png2 = None
        else:
            path_template = os.path.join(run_quality_dir, run_element.id+'_1')
            nb_read,nb_good_qual_read1,qual_tile_png1  = tmp_get_qc_res2(path_template)
            path_template = os.path.join(run_quality_dir, run_element.id+'_2')
            nb_read,nb_good_qual_read2,qual_tile_png2  = tmp_get_qc_res2(path_template)
            
    return nb_read,nb_good_qual_read1,qual_tile_png1,nb_good_qual_read2,qual_tile_png2


def load_qc_in_run_page(run_quality_dir, run_page):
    for run_element in run_page.run.get_lanes():
        nb_read, nb_good_qual_read1, qc_file1,\
        nb_good_qual_read2, qc_file2 = get_qc_from_seq_archive(run_quality_dir, run_element,
                                                               run_page.run.is_single_end())
        run_element.nb_reads=nb_read
        run_element.nb_gq_reads1=nb_good_qual_read1
        run_element.nb_gq_reads2=nb_good_qual_read2
        if qc_file1 and os.path.exists(qc_file1):
            run_element.add_file(qc_file1, 'solexa_qa1')
        if qc_file2 and os.path.exists(qc_file2):
            run_element.add_file(qc_file2, 'solexa_qa2')
    if run_page.run.is_indexed():
        index_files =os.path.join(run_quality_dir,'index.stats')
        for run_element in run_page.run.get_run_elements():
            command = "grep '%s' %s"%(run_element.id,index_files)
            output = get_output_stream_from_command(command)
            line=output.readline()
            if line and len(line.split())>1:
                nb_reads = line.split()[1]
                run_element.nb_reads=int(nb_reads)
    
    for run_element in run_page.run.get_run_elements():
        read_with_adapter = os.path.join(run_quality_dir, run_element.id+'_with_adapter.txt')
        
        command = "cat %s | wc -l"%(read_with_adapter)
        print command
        output,process= get_output_stream_from_command(command)
        line=output.readline()
        print line
        if line and len(line.split())>0:
            nb_reads = line.split()[0]
            run_element.nb_reads_with_adapter=int(nb_reads)
        
  
def tmp_get_qc_res(path_template):
    nb_read=None
    nb_good_qual_read=None
    qual_tile_png=None
    path =path_template+'_good_quality_len_distribution.qv'
    if os.path.exists(path):
        command = """less %s | awk '{a+=$2; if ($1>0.75) b+=$2} END{print a"\t"b}'"""%path
        stream,process = utils_commands.get_output_stream_from_command(command)
        sp_line = stream.readline().split()
        if len(sp_line)==2:
            nb_read, nb_good_qual_read=sp_line
            nb_read=int(nb_read)
            nb_good_qual_read=int(nb_good_qual_read)
        for line in stream:
            pass
    path = path_template+'.solfastq.png'
    if os.path.exists(path):
        qual_tile_png=path
    return nb_read,nb_good_qual_read,qual_tile_png


def tmp_get_qc_res2(path_template):
    nb_read=None
    nb_good_qual_read=None
    qual_tile_png=None 
    path =path_template+'_fastqc/fastqc_data.txt'
    if os.path.exists(path):
        nb_read, nb_good_qual_read = parse_fastqc_file(path)
    path = path_template+'.solfastq.png'
    if os.path.exists(path):
        qual_tile_png=path
    return nb_read,nb_good_qual_read,qual_tile_png


def parse_fastqc_file(file):
    open_file = utils_logging.open_input_file(file, pipe=False)
    #section parse
    section_name = None
    section_dictionnary={}
    for line in open_file:
        if line.startswith('>>END_MODULE'):
            section_name = None
        elif line.startswith('>>'):
            section_name = line.strip().strip('>>').split('\t')[0]
            section_dictionnary[section_name]=[]
        elif section_name:
            section_dictionnary[section_name].append(line.strip())
    nb_read = None
    nb_good_qual_read = None
    if section_dictionnary.has_key("Basic Statistics"):
        nb_read = 0
        for line in section_dictionnary.get("Basic Statistics"):
            if line.startswith('Total Sequences'):
                nb_read = int(line.split()[-1])
    
    if section_dictionnary.has_key("Per sequence quality scores"):
        nb_good_qual_read = 0
        #two columns table
        for line in section_dictionnary.get("Per sequence quality scores"):
            if line.startswith('#'):
                pass
            else:
                quality, count= line.split()
                if int(quality)>=27:
                    nb_good_qual_read += int(float(count))
    
    open_file.close()
    return nb_read,nb_good_qual_read
    

def main():
    #initialize the logging
    utils_logging.init_logging(logging.INFO)
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if options.debug:
        utils_logging.init_logging(logging.DEBUG)
    if not options.print_out:
        command_runner.set_command_to_run_localy()
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    
    if options.run_page_title:
        if options.check:
            find_run_data(options.run_page_title, options.output_dir)
        else:
            run_quality_check(options.output_dir, options.run_page_title, options.overwrite, no_thread=options.no_thread,
                              index_only=options.index)
    else:
        run_all_quality_check(options.output_dir, options.overwrite, options.check)


def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-i input> <-o outputPath> [-q quality -f]"""
    description = """This script is a template to of a python script that include help and option's checking.
    The requirement and assumption of the script can be described here.
    A link to another documentation can also be added here."""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-r","--run_page_title",dest="run_page_title",type="string",
                         help="Title of the run page on the wiki. Default: %default")
    optparser.add_option("-o","--output",dest="output_dir",type="string",
                         help="Path to a directory where the run directory will be created. Default: %default")
    optparser.add_option('-f',"--force",dest="overwrite",action="store_true",default=False,
                         help="This flag force the script to overwrite. Default: %default")
    optparser.add_option('-c',"--check",dest="check",action="store_true",default=False,
                         help="This flag set the script to check if the data is there. Default: %default")
    optparser.add_option("--no_thread",dest="no_thread",action="store_true",default=False,
                         help="This flag set the script to not use thread. Default: %default")
    optparser.add_option("--debug",dest="debug",action="store_true",default=False,
                         help="This flag set the script to output all debug information. Default: %default")
    optparser.add_option("--print",dest="print_out",action="store_true",default=False,
                         help="This flag set the script to print the commands instead of executing them. Default: %default")
    optparser.add_option("--index",dest="index",action="store_true",default=False,
                         help="This flag set run only the indexed part of the script. Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.output_dir:
        logging.error("You must specify an output directory.")
        arg_pass=False
    return arg_pass



if __name__=="__main__":
    main()
    

    
if __name__=="1__main__":
    utils_logging.init_logging()
    command_runner.set_command_to_run_localy()
    get_all_run_page_titles(type='SOLEXA')
    all_page_parents_and_titles = get_all_run_page_titles(type='SOLEXA')
    output_dir='/home/tcezard/temp/run_quality_data/'
    for parent_page_title, run_page_title in all_page_parents_and_titles:
        if run_page_title.startswith('08') or run_page_title.startswith('090'):
            continue
        
        run_quality_check(output_dir, run_page_title)
        
if __name__=="1__main__":
    utils_logging.init_logging()
    command_runner.set_command_to_run_localy()        
    run_page_title = '100129_HWUSI_EAS222_619EBAAAXX'
    output_dir='/home/tcezard/temp/run_quality_data/'
    run_page=get_run_page_from_title(run_page_title)
    run_page.load_light_page_content()
    for run_element in run_page.run.get_lanes():
        print QC_results_exist(os.path.join(output_dir,shellize_file_name(run_page_title)),
                         run_element.id, run_page.run.is_single_end())
if __name__=="1__main__":
    utils_logging.init_logging()
    command_runner.set_command_to_run_localy()
    run_page_title='100917_HWUSI-EAS721_00008_FC_62BW2AAXX'
    try :
        run_page=get_run_page_from_title(run_page_title)
    except Wiki_Parser_Error, e:
        run_page=None
        logging.error('%s on %s'%(str(e), run_page_title))
    overwrite=False
    run_dir='/home/tcezard/temp/'
    
    for run_element in run_page.run.get_run_elements():
        print run_element
        try:
            thread = Threaded_fastq_analysis(run_element, run_dir, overwrite,
                                             analyze_fastq=simple_analyze_fastq, is_index=True)
            #thread.start()
            thread.run()
            #time.sleep(2)
        except StandardError:
            logging.exception('CRASH')
        
        

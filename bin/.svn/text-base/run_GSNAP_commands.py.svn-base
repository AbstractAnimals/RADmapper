#!/usr/bin/env python
'''
Created on 4 Feb 2010

@author: tcezard
'''
import os, sys, logging
from optparse import OptionParser
import utils
from utils import utils_param, utils_logging, compare_version_number,\
    get_bwa_version, longest_common_substr_from_start,\
    sort_bam_file_per_coordinate
import command_runner
from utils.GenomeLoader import GenomeLoader
from utils.parameters import Config_file_error
from create_junction_for_GSNAP import create_junction_for_GSNAP

FASTQ_SANGER="sanger"
FASTQ_ILLUMINA="illumina"

PREPARE_GENOME='prepare_genome'
ALIGN_READS='align_reads'
RUN_TYPE=[PREPARE_GENOME,ALIGN_READS]
ANALYSIS_DIGITAL_TRANSC='digital_transc'
ANALYSIS_RNA_SEQ='rna_seq'
ANALYSIS_TYPE=[ANALYSIS_DIGITAL_TRANSC,ANALYSIS_RNA_SEQ]


def extract_name(file):
    if file.endswith('.gz'):
        file,ext=os.path.splitext(file)
    file_name, ext= os.path.splitext(file)
    return os.path.basename(file_name)

def check_indexes(genome_file, snps_file=None, annotation_file=None):
    genome_templates=["%s.chromosome",
                "%s.chromosome.iit",
                "%s.chrsubset",
                "%s.contig",
                "%s.contig.iit",  
                "%s.genomecomp",
                "%s.maps",
                "%s.ref3offsets", 
                "%s.ref3positions",  
                "%s.version"]
    annotation_templates=["%s.maps/%s.iit"]
    snps_templates=['%s.ref3offsets.%s',
                   '%s.genomecomp.%s',
                   '%s.ref3positions.%s',
                   "%s.maps/%s.iit"]
    
    genome_index_valid=True
    annotation_index_valid=True
    snps_index_valid=True
    
    genome_name = extract_name(genome_file)
    output_directory=os.path.join(os.path.dirname(os.path.abspath(genome_file)),genome_name)
    genome_path=os.path.join(output_directory,genome_name)
    for template in genome_templates:
        path = template%genome_path
        if not os.path.exists(path):
            logging.error("%s doesn't exist"%(path))
            genome_index_valid=False
            
    if annotation_file:
        annotation_name=extract_name(annotation_file)
        output_directory
        for template in annotation_templates:
            path=template%(os.path.join(output_directory,genome_name), annotation_name)
            if not os.path.exists(path):
                logging.error("%s doesn't exist"%(path))
                annotation_index_valid=False
    
    if snps_file:
        snps_name=extract_name(snps_file)
        for template in snps_templates:
            path = template%(genome_path,snps_name)
            if not os.path.exists(path):
                logging.error("%s doesn't exist"%(path))
                snps_index_valid=False
        
    return genome_index_valid,annotation_index_valid,snps_index_valid
            


def prepare_genome(genome_file, snps_file, annotation_file, clean_up=True):
    run_fine=True
    pipeline_param=utils_param.get_pipeline_parameters()
    gsnap_dir=pipeline_param.get_gsnap_dir()
    gmap_build_bin=os.path.join(gsnap_dir,'gmap_build')
    iit_store_bin=os.path.join(gsnap_dir,'iit_store')
    snpindex_bin=os.path.join(gsnap_dir,'snpindex')
    #index the genome with gmap build
    output_directory=os.path.dirname(os.path.abspath(genome_file))
    assembly_name, ext=os.path.splitext(os.path.basename(genome_file))
    
    command='%s -D %s -d %s %s'%(gmap_build_bin, output_directory, assembly_name, genome_file)
    command_runner.run_command(command)
    files_to_remove=[]
    #index the snps file with the reference sequence
    if snps_file:
        snps_name, ext = os.path.splitext(os.path.basename(snps_file))
        snps_store = snps_name
        command = 'cat %s | %s -o %s'%(snps_file, iit_store_bin, snps_store)
        command_runner.run_command(command)
        snps_store+='.iit'
        
        command = '%s -D %s -d %s -V %s -v %s %s'%(snpindex_bin, output_directory, assembly_name, output_directory, snps_name, snps_store)
        command_runner.run_command(command)
        index_map_dir=os.path.join(output_directory,assembly_name,assembly_name+'.maps')
        command = 'mv %s %s'%(snps_store,index_map_dir)
        command_runner.run_command(command)
        
    if annotation_file:
        name = extract_name(annotation_file)
        junction_txt=os.path.join(output_directory, name+'.splicesites')
        logging.info("Create the  junctions from %s"%(annotation_file))
        create_junction_for_GSNAP(annotation_file, output_file=junction_txt)
        
        junction_iit=os.path.join(output_directory, name)
        command="cat %s | iit_store -o %s"%(junction_txt, junction_iit)
        command_runner.run_command(command)
        index_map_dir=os.path.join(output_directory,assembly_name,assembly_name+'.maps')
        command="mv %s.iit %s"%(junction_iit,index_map_dir)
        command_runner.run_command(command)
        
        files_to_remove.append(junction_txt)
        logging.info("junction name: %s"%(name))
        
    if clean_up:
        return_code = remove_file(files_to_remove)
        if return_code is not 0:
            run_fine = False
    return run_fine


def detect_sanger_solexa_fastq(fastq_file):
    open_fastq = utils_logging.open_input_file(fastq_file)
    nb_line=0
    all_quals=set()
    for line in open_fastq:
        nb_line+=1
        if nb_line>=4000:
            break
        if nb_line%4==0:
            quals=map(ord,line.strip())
            all_quals.update(set(quals))
    
    minimum = min(all_quals)
    maximum = max(all_quals)
    if minimum<63 and maximum<75:
        return FASTQ_SANGER
    else:
        return FASTQ_ILLUMINA

#gsnap --gunzip -B 4 -t 10 -o FR -m 4 -E 100 -D ~/projects/2010053_Tom_Little_RNAseq_2/reference/gsnap/ 
#-d dmagna-v2.4-20100422-assembly -s daphmagna_201104m8.pasaupdate_splicesites -N 1 --quality-protocol=illumina 
#--format=sam  --read-group-id=4CR2 --read-group-name=4CR2 /home/tcezard/projects/2010053_Tom_Little_RNAseq_2/raw_data_from_webserver/4-C-R2/4-C-R2_1.txt.gz 
#/home/tcezard/projects/2010053_Tom_Little_RNAseq_2/raw_data_from_webserver/4-C-R2/4-C-R2_2.txt.gz 2> 
#/home/tcezard/projects/2010053_Tom_Little_RNAseq_2/raw_data_from_webserver/gsnap/without_snps/4CR2_with_splice_with_snp_gsnap.log 
#| awk '{if (and($2,256)!=256) print }'> /home/tcezard/projects/2010053_Tom_Little_RNAseq_2/raw_data_from_webserver/gsnap/without_snps/4CR2_with_splice.sam

    
def run_GSNAP_Command(genome_file, fastq_file1, fastq_file2=None, output_dir=None, sample_name=None,
                    clean_up=True, sort=False, thread=1, annotation_file=None, snps_file=None,
                    read_group_id=None, read_group_sample=None, read_group_library=None,quality_protocol='sanger'):
    pipeline_param=utils_param.get_pipeline_parameters()
    gsnap_dir=pipeline_param.get_gsnap_dir()
    
    run_fine=True
    try:
        pipeline_param=utils_param.get_pipeline_parameters()
        gsnap_dir=pipeline_param.get_gsnap_dir()
        samtools_dir=pipeline_param.get_samtools_dir()
        picard_dir=pipeline_param.get_picard_dir()
    except Config_file_error, e:
        logging.warning("You'll need to have gsnap and samtools in your path")
        gsnap_dir=''
        samtools_dir=''
        picard_dir=None
        
    #Get the sample name
    if fastq_file2:
        fastq_common = longest_common_substr_from_start(fastq_file1,fastq_file2)
        #remove trailing underscore _ and get the base name
        sample_name = os.path.basename(fastq_common.rstrip('_'))
    else:
        tmp,ext=os.path.splitext(os.path.basename(fastq_file1))
        sample_name = os.path.basename(tmp.rstrip('_1'))
    
    gsnap_bin=os.path.join(gsnap_dir,'gsnap')
    samtools_bin=os.path.join(samtools_dir,'samtools')
    
    files_and_dir=[]
    
    if output_dir is None: 
        output_dir=os.path.dirname(fastq_file1)
    command_array=[]
    command_array.append(gsnap_bin)
    name,ext =  os.path.splitext(fastq_file1)
    if ext==".gz":
        command_array.append("--gunzip")
    command_array.append("-B 4")
    command_array.append("-t %s"%(thread))
    command_array.append("-o FR")
    command_array.append("-m 4")
    command_array.append("-E 100") #This will prevent any read to be split accross long junctions
    genome_dir = os.path.dirname(genome_file)
    genome_file_name = os.path.basename(genome_file)
    genome_name, dummy=os.path.splitext(genome_file_name)
    command_array.append("-D %s -d %s"%(genome_dir, genome_name))
    if annotation_file: 
        command_array.append("-s %s"%(extract_name(annotation_file)))
    if snps_file:
        command_array.append("-v %s"%(extract_name(snps_file)))
    command_array.append("-N 1")
    if quality_protocol is None:
        logging.info("Detect fastq format")
        if detect_sanger_solexa_fastq(fastq_file1)==FASTQ_ILLUMINA:
            command_array.append("--quality-protocol=illumina")
        else:
            command_array.append("--quality-protocol=sanger")
    else:
        if quality_protocol is FASTQ_ILLUMINA:
            command_array.append("--quality-protocol=illumina")
        else:
            command_array.append("--quality-protocol=sanger")
    command_array.append("--format=sam")
    if read_group_id:
        command_array.append("--read-group-id=%s"%read_group_id)
    else:
        command_array.append("--read-group-id=%s"%sample_name)
    if read_group_sample:
        command_array.append("--read-group-name=%s"%read_group_sample)
    else:
        command_array.append("--read-group-name=%s"%sample_name)
    if read_group_library:
        command_array.append("--read-group-library=%s"%read_group_library)
    else:
        command_array.append("--read-group-library=%s"%sample_name)
    command_array.append("--read-group-platform=ILLUMINA")

    command_array.append("-N 1")
    command_array.append(fastq_file1)
    if fastq_file2:
        command_array.append(fastq_file2)
    #that's just a hack to keep only the primary hit
    command_array.append("| awk '{if (and($2,256)!=256) print }'")
    
    sam_file=os.path.join(output_dir, sample_name+'.sam')
    command_array.append("> %s"%(sam_file))
    
    command=" ".join(command_array)
    
    return_code = command_runner.run_command( command)
    files_and_dir.append(sam_file)
    
    if return_code is not 0:
        run_fine = False
    
    if picard_dir:
        fix_bam_file=os.path.join(output_dir,sample_name+'_fixed.bam')
        picard_Fix_mate=os.path.join(picard_dir,"FixMateInformation.jar")
        command = "java -jar -Xmx3G %s I=%s O=%s VALIDATION_STRINGENCY=LENIENT SO=coordinate"%(picard_Fix_mate, sam_file, fix_bam_file)
        return_code = command_runner.run_command( command)
    else: 
        sorted_bam_file=os.path.join(output_dir,sample_name+'read_name_sorted')
        command='%s view -bt %s %s | %s sort -n - %s'%(samtools_bin, genome_file, sam_file, samtools_bin, sorted_bam_file)
        return_code = command_runner.run_command( command)
        sorted_bam_file=sorted_bam_file+'.bam'
        files_and_dir.append(sorted_bam_file)
        
        fixed_bam_file_tmp=os.path.join(output_dir,sample_name+'fixed_tmp.bam')
        command='%s fixmate %s %s'%(samtools_bin, sorted_bam_file, fixed_bam_file_tmp)
        return_code = command_runner.run_command( command)
        files_and_dir.append(fixed_bam_file_tmp)
        
        fixed_bam_file=os.path.join(output_dir,sample_name+'fixed.bam')
        command='%s sort %s %s | %s sort -n - %s'%(samtools_bin, sorted_bam_file, fixed_bam_file)
        return_code = command_runner.run_command( command)
        
    if run_fine and clean_up:
        return_code = remove_file(files_and_dir)
        if return_code is not 0:
            run_fine = False
    
    return run_fine
        
def remove_file(files_and_dir):
    return command_runner.run_command( 'rm -fr %s'%(' '.join(files_and_dir)))




def main():
    #initialize the logging
    utils_logging.init_logging()
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    utils_logging.change_log_stdout_to_log_stderr()
    if options.print_commands:
        utils_logging.change_log_stdout_to_log_stderr()
    else:
        command_runner.set_command_to_run_localy()
    (genome_valid, snps_valid, annotation_valid) = check_indexes(options.genome_file, options.snps_file, options.annotation_file)
    run_fine=True
    if not genome_valid or not snps_valid or not annotation_valid:
        run_fine = prepare_genome(options.genome_file, options.snps_file, options.annotation_file)
    if run_fine:
        run_fine=run_GSNAP_Command(options.genome_file, options.fastq_file1, options.fastq_file2,
                             options.output_dir, sample_name=options.name, annotation_file=options.annotation_file,
                             snps_file=options.snps_file, thread=options.thread, read_group_id=options.read_group_id,
                             read_group_sample=options.read_group_sample, read_group_library=options.read_group_library,
                             quality_protocol=options.quality_protocol)
    if run_fine:
        logging.info('Run completed')
    else:
        logging.error('Run Failed')
        sys.exit(1)
        
def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-g genome_fasta> <-1 first fastq file> [ -2 second fastq file -n sample_name]"""
    description = """This script will align read in Sanger fastq format to a reference genome and create a bam file. using GSNAP and Picard"""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-g","--genome_file",dest="genome_file",type="string",
                         help="Path to a fasta file where the genome is located. Default: %default")
    optparser.add_option("-1","--fastq1",dest="fastq_file1",type="string",
                         help="Path to the first fastq file where the first reads are. This file is mandatory. Default: %default")
    optparser.add_option("-2","--fastq2",dest="fastq_file2",type="string",
                         help="Path to the second fastq file where the second reads are. This file is optional. Default: %default")
    optparser.add_option("-o","--output_dir",dest="output_dir",type="string",
                         help="The path to the directory where the results will be output. If not set, the results will be put in the same folder as fastq1. Default: %default")
    optparser.add_option("-n","--name",dest="name",type="string",
                         help="The name of the sample currently being aligned. Default: %default")
    optparser.add_option("-t", "--thread",dest="thread",type='int',default=1,
                         help="Number of thread used by the alignment algorithm. Default: %default")
    optparser.add_option("--print",dest="print_commands",action='store_true',default=False,
                         help="Print the command instead of running them. Default: %default")
    optparser.add_option("--snps",dest="snps_file",type="string",default=False,
                         help="when preparing the genome this file can be used to be index with the genome. Default: %default")
    optparser.add_option("--annotation_file",dest="annotation_file",type="string",default=False,
                         help="when preparing the genome this file can be used to create the exons-exons junctions. Default: %default")
    optparser.add_option("--readgroup_id",dest="read_group_id",type="string",help="Set read group ID for SAM file.")
    optparser.add_option("--readgroup_sample",dest="read_group_sample",type="string",help="Set read group SM for SAM file.")
    optparser.add_option("--readgroup_library",dest="read_group_library",type="string",help="Set read group PL for SAM file.")
    optparser.add_option("--quality_protocol",dest="quality_protocol",type="string",default="sanger",
                         help="Set the fastq quality encoding to either "+FASTQ_ILLUMINA+" or "+FASTQ_SANGER+".")
    
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.genome_file :
        logging.error("You must specify a genome fasta file.")
        arg_pass=False
    elif not os.path.exists(options.genome_file):
        logging.error("Genome fasta file not found. You must specify an existing genome fasta file.")
        arg_pass=False
        
    if not options.fastq_file1:
        logging.error("You must specify at least one fastq file.")
        arg_pass=False
    elif not os.path.exists(options.fastq_file1):
        logging.error("fastq1 file %s not found. You must specify an existing file."%options.fastq_file1)
        arg_pass=False
    if options.fastq_file2:
        if not os.path.exists(options.fastq_file2):
            logging.error("fastq2 file %s not found. You must specify an existing file."%options.fastq_file2)
            arg_pass=False
    if options.output_dir:
        if not os.path.exists(options.output_dir):
            logging.error("output directory %s not found. You must specify an existing directory."%options.output_dir)
            arg_pass=False
    return arg_pass



if __name__=="__main__":
    main()
    #detect_sanger_solexa_fastq(sys.argv[1])

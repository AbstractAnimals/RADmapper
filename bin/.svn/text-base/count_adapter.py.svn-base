'''
Created on Nov 11, 2010

@author: tcezard
'''
import os
import logging
from subprocess import Popen, PIPE
from optparse import OptionParser
import sys
from threading import Thread

all_handlers={}
def init_logging(output_level=logging.INFO, file_level=logging.INFO, log_file_name=None, overwrite=False, logger_name='', formatter=None):
    """initialise the logging with default parameter.
If use several time with same input file only the level of the logging will be change.
@param output_level: The logging level of output for the stdout. If set to None the stdout is not set or not changed. default: INFO.
@param file_level: The logging level of output for the log file. if set to None the logging in a file is not set or not changed. default: INFO.
@param log_file_name: The name of the file used for the logging. if set to None the logging in a file is not set or not changed. default: None.
@param overwrite: if set to true an existing log file will overwritten, otherwise the next log will be appended. default: None.
@param logger_name: Initialise non root logger that will be accessible through logging.getLogger(name). default: ''.
@param logger_name: set non default formatter that will be use to format the logging. default: ''.
Example:
init_logging() --> set the stdout only to INFO
init_logging(log_file_name="any_file") --> set the stdout and the log file to INFO
init_logging(output_level=None, log_file_name="any_file") --> set the log file only to INFO don't touch the stdout
"""
    if logger_name is not '':
        logging.root.setLevel(logging.NOTSET)
    
    if formatter is None:
        formatter=logging.Formatter('%(levelname)s %(message)s')
    
    if output_level is not None:
        #user wants to set the something to the output logger
        handler_info=all_handlers.get(logger_name+"std_out")
        
        if handler_info is None:
            #create a new handler
            console_handler=logging.StreamHandler(sys.stdout)
            current_logger=logging.getLogger(logger_name)
            current_logger.addHandler(console_handler)
            current_logger.setLevel(logging.NOTSET)
            current_logger.propagate=0
            all_handlers[logger_name+"std_out"]=(console_handler,output_level)
        else:
            (console_handler,current_level)=handler_info
        console_handler.setLevel(output_level)
        console_handler.setFormatter(formatter)

    if log_file_name and file_level is not None:
        handler_info=all_handlers.get(logger_name+log_file_name)
        if handler_info is None:
            #create a new handler
            if overwrite:
                file_handler = logging.FileHandler(log_file_name, 'w')
            else:
                file_handler = logging.FileHandler(log_file_name, 'a')
            current_logger=logging.getLogger(logger_name)
            current_logger.addHandler(file_handler)
            current_logger.setLevel(logging.NOTSET)
            current_logger.propagate=0
            all_handlers[logger_name+log_file_name]=(file_handler,file_level)
        else:
            (file_handler,current_level)=handler_info
        file_handler.setLevel(file_level)
        file_handler.setFormatter(formatter)
        
    return logging.getLogger(logger_name)

###################################
#        Command utilities        #
###################################
class Output_Logger(Thread):
    """Close the stdin and log the stdout and stderr using logging module.
    All the logging is done in a separate thread so it won't block because a buffer is full.
    You can specify the logger name that should be used but this logger should already be created in the logging module."""
    def __init__(self,stdin,stdout,stderr, logger_name=''):
        self.stdin=stdin
        self.stdout=stdout
        self.stderr=stderr
        if logger_name is not None:
            self.logger=logging.getLogger(logger_name)
        else:
            self.logger=None
        Thread.__init__(self)
        
    def run(self):
        import select
        read_set = []
        #the stdin need to be closed no information come through it or the select will freeze.
        self.stdin.close()
        
        if self.stdout:
            read_set.append(self.stdout)
        if self.stderr:
            read_set.append(self.stderr)

        while read_set :
            rlist, wlist, xlist = select.select(read_set, [], [])

            if self.stdout in rlist:
                line = self.stdout.readline().strip()
                if not line:
                    self.stdout.close()
                    read_set.remove(self.stdout)
                elif self.logger:
                    self.logger.info(line)

            if self.stderr in rlist:
                line = self.stderr.readline().strip()
                if not line:
                    self.stderr.close()
                    read_set.remove(self.stderr)
                elif self.logger:
                    self.logger.error(line)


def launchCommand(command, verbose=True, logger_name='', cwd=None):
    if not verbose:
        logging.getLogger(logger_name).setLevel(logging.CRITICAL)
    process=launchCommand_no_wait(command, logger_name, cwd)
    return_code=process.wait()
    if not verbose:
        logging.getLogger('').setLevel(logging.NOTSET)
    logging.info("pid=%s returned %s"%(process.pid,return_code))
    return return_code

def launchCommand_no_wait(command, logger_name='', cwd=None):
    process=Popen(command, stdin=PIPE, stdout=PIPE, stderr=PIPE, shell=True, executable='/bin/bash', cwd=cwd)
    logger=Output_Logger(process.stdin, process.stdout, process.stderr, logger_name)
    logger.setDaemon(True)
    logger.start()
    return process

def detect_adapter_command(fastq_file, fasta2fastq_bin, blastall_bin, adtapter_database, read_with_adapter):
    
    if fastq_file.endswith('.gz'):
        start_command='gunzip -c '
    else:
        start_command='cat '
    
    command = '''%s %s | %s | %s -p blastn -d %s -e 1e-4 -m 8 -a 8 -F f | awk '{print substr($1,1,length($1)-2)}' | sort -u > %s'''
    command = command%(start_command, fastq_file, fasta2fastq_bin, blastall_bin, adtapter_database, read_with_adapter)
    return command
    
    
def count_adapter_from_fastq(fastq_files, read_with_adapter, adtapter_database):
    
    fasta2fastq_bin='sol2fasta.pl'
    blastall_bin='blastall'
    
    if len(fastq_files)==1:
        #single end
        command = detect_adapter_command(fastq_files[0], fasta2fastq_bin, blastall_bin, adtapter_database, read_with_adapter)
        print command
        return_code = launchCommand(command)
        
    elif len(fastq_files)==2:
        #paired end
        read_with_adapter1=read_with_adapter+'.1'
        read_with_adapter2=read_with_adapter+'.2'
        command1 = detect_adapter_command(fastq_files[0], fasta2fastq_bin, blastall_bin, adtapter_database, read_with_adapter1)
        print command1
        command2 = detect_adapter_command(fastq_files[1], fasta2fastq_bin, blastall_bin, adtapter_database, read_with_adapter2)
        print command2
        process1 = launchCommand_no_wait(command1)
        process2 = launchCommand_no_wait(command2)
        return_code=process1.wait()
        logging.info("pid=%s returned %s"%(process1.pid,return_code))
        return_code=process2.wait()
        logging.info("pid=%s returned %s"%(process2.pid,return_code))

        command = 'cat %s %s | sort -u > %s'%(read_with_adapter1,read_with_adapter2,read_with_adapter) 
        print command
        launchCommand(command)
        command = 'rm -f %s %s'%(read_with_adapter1,read_with_adapter2)
        print command
        launchCommand(command)
    else:
        logging.error('%s fastq file(s) found in input '%len(fastq_files))
    
    

def main():
    #Setup options
    init_logging(logging.INFO)
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    fastq_files=options.fastq_files.split(',')
    if len(args)>0:
        fastq_files.extend(args)
    count_adapter_from_fastq(fastq_files, options.output_read_with_adapter, options.adtapter_database)


def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-i input> <-o outputPath> [-q quality -f]"""
    description = """This script is count the number of adapter contained in a fastq file."""
    
    optparser = OptionParser(description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-f","--fastq_files",dest="fastq_files",type="string",
                         help="the fastq files where the search should be performed. Default: %default")
    optparser.add_option("-o","--output",dest="output_read_with_adapter",type="string",
                         help="Path to the file where the name of the reads that contain adapter will be output. Default: %default")
    optparser.add_option('-d',"--adtapter_database",dest="adtapter_database",type="string",
                         help="path to the fasta file that contains the adapter we need to search for. Default: %default")
    
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.fastq_files:
        logging.error("You must specify at least one fastq file.")
        arg_pass=False
    if not options.output_read_with_adapter:
        logging.error("You must specify an output file.")
        arg_pass=False
    if not options.adtapter_database:
        logging.error("You must specify an adapter database indexed with blast.")
        arg_pass=False
    else:
        if not os.path.exists(options.adtapter_database):
            logging.error("You must specify one adapter database indexed with formatdb.")
            arg_pass=False
        if not os.path.exists(options.adtapter_database+'.nhr'):
            logging.error("You must index the adapter database with formatdb.")
            arg_pass=False
        elif not os.path.exists(options.adtapter_database+'.nin'):
            logging.error("You must index the adapter database with formatdb.")
            arg_pass=False
        elif not os.path.exists(options.adtapter_database+'.nsq'):
            logging.error("You must index the adapter database with formatdb.")
            arg_pass=False
            
    return arg_pass



if __name__=="__main__":
    main()


    
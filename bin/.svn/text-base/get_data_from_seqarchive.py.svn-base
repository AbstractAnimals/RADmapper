'''
Created on 23 Jun 2010

@author: tcezard
'''
from utils.utils_commands import get_output_stream_from_command
    
from wiki_communication import get_wiki_project
import logging
from utils import utils_logging, utils_param, copy_file_across
import utils
import os
import command_runner
import sys
from optparse import OptionParser
from pipeline_directory_structure import create_directory_structure
from utils.utils_param import Config_file_error, get_pipeline_places



def find_seq_archive_file_on_server(server, path, run_id, lane, index_id=None, single_end=True):
    info = run_id.split('_')
    if len(info)==2:
        run_date, flowcel_id = run_id.split('_')
    elif len(info)==3:
        run_date, counter, flowcel_id = run_id.split('_')
    #run_id = '%s_%s'%(run_date,flowcel_id)
    if index_id:
        index_str='_%s'%index_id
    else:
        index_str=''
    if single_end:
        paired_end_str=''
    else:
        paired_end_str='_?'
    pattern_to_try=['*_%s%s_sequence%s.txt.gz'%(lane,paired_end_str,index_str),
                    '%s_*%s_%s%s%s.txt.gz'%(run_date,flowcel_id, lane, index_str,paired_end_str),
                    '%s_%s%s%s.txt.gz'%(run_date,lane,paired_end_str,index_str),
                    '%s_*%s_%s%s%s.sanfastq.gz'%(run_date,flowcel_id,lane,index_str,paired_end_str)]
    for pattern in pattern_to_try:
        if server:
            command='''ssh %s "ls %s/%s*/%s"'''%(server, path, run_date, pattern)
        else:
            command='''ls %s/%s*/%s '''%(path, run_date, pattern)
        logging.debug(command)
        stream, process= get_output_stream_from_command(command, logger_name=None)
        paths=[]
        for line in stream:
            paths.append(line.strip())
        
        if single_end and len(paths)>1:
            logging.error('Found %s paths on %s with pattern %s for run %s lane %s\n %s'%(len(paths), server,
                                                                                        pattern, run_id, lane,
                                                                                        ' and '.join(paths)))
            paths=[]
        elif not single_end and len(paths)>2:
            logging.error('Found %s paths on %s with pattern %s for run %s lane %s\n %s'%(len(paths), server,
                                                                                          pattern, run_id, lane,
                                                                                          ' and '.join(paths)))
            paths=[]
        elif not single_end and len(paths)==1:
            logging.error('Found %s paths on %s with pattern %s for run %s lane %s\n %s'%(len(paths), server, 
                                                                                          pattern, run_id, lane,
                                                                                          ' and '.join(paths)))
            paths=[]
        if len(paths)>0:
            break
    return paths

def find_seq_archive_file(run_id, lane, index_id=None, single_end=True):
    """This function check several places to find seqarchive files."""
    pipeline_places = get_pipeline_places()
    seq_archive_places = pipeline_places.get_seq_archive()
    for seq_archive_path in seq_archive_places:
        if len(seq_archive_path.split(':'))>1:
            server,path = seq_archive_path.split(':')
        else:
            server = None
            path = seq_archive_path
            
        paths=find_seq_archive_file_on_server(server,path,run_id, lane, index_id, single_end)
        for i in range(len(paths)):
            paths[i]=(server,paths[i])
        if len(paths)>0:
            break
            
    return paths


def solexa_fastq_to_sanger_fastq(solexa_fastq_file):
    
    base,ext=os.path.splitext(solexa_fastq_file)
    if ext=='.gz':
        reader='zcat'
        base,dummy=os.path.splitext(base)
    else:
        reader='cat'
    
    sanger_fastq_file=base+'.fastq'
    if not os.path.exists(sanger_fastq_file):
        command='%s %s | /ifs/software/linux_x86_64/maq/maq-0.7.1/scripts/fq_all2std.pl sol2std2 > %s'%(reader,solexa_fastq_file,
                                                                                                    sanger_fastq_file)
        command_runner.run_command(command)
    return sanger_fastq_file


def get_data_from_seqarchive(all_projects_folder, project_id, sample_id, run_element_id, overwrite=False, sanger_fastq=True, link=False):
    #load the information from the wiki
    project=get_wiki_project(project_id)
    if not project:
        logging.error('project %s was not found on wiki'%(project_id))
        return False
    sample=project.get_sample(sample_id)
    if not sample:
        logging.error('sample %s was not found in project %s '%(sample_id,project_id))
        return False
    run_element=sample.get_run_element(run_element_id)
    if not run_element:
        logging.error('run element %s was not fount in project %s sample %s'%(run_element_id,project_id,sample_id))
        return False
    if not run_element.is_usable():
        logging.info('%s -- %s -- %s is not usable'%(project_id,sample_id,run_element_id))
        return False
    
    #create directory for the main projects folder
    project_dir, sample_dir, run_dir = create_directory_structure(all_projects_folder, project_id, sample_id, run_element_id)
    if link:
        fastq_files = get_link_from_seq_archive(run_element, run_dir, overwrite=overwrite)
    else:
        fastq_files= get_files_from_seq_archive(run_element, run_dir, overwrite=overwrite)
    if sanger_fastq:
        sanger_fastq_files=[]
        for i in range(len(fastq_files)):
            if fastq_files[i].endswith('sanfastq.gz') or fastq_files[i].endswith('sanfastq'):
                sanger_fastq_files.append(fastq_files[i])
                continue
            solexa_fastq_file=fastq_files[i]
            b,dummy=os.path.splitext(solexa_fastq_file.rstrip('.gz'))
            sanger_fastq_file=b+'.fastq'
            sanger_fastq_files.append(sanger_fastq_file)
            
            return_code = sol_fastq_2_sang_fastq(solexa_fastq_file, sanger_fastq_file, overwrite)
            if return_code == 0:
                command='rm -f %s'%(solexa_fastq_file)
                command_runner.run_command(command)
        return sanger_fastq_files
    else:
        return fastq_files


def get_files_from_seq_archive(run_element, dest_dir, server_destination=None, overwrite=False):
    server_and_paths=find_files_in_seq_archive(run_element)
    run_element_id=run_element.id
    single_end=run_element.run.is_single_end()
    fastq_files=[]
    fastq_files_tmp=[]
    if single_end:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id))
    else:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_1'))
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_2'))
        
    for i in range(len(server_and_paths)):
        server, path=server_and_paths[i]
        fastq_file=fastq_files_tmp[i]
        b,s=os.path.splitext(path)
        if b.endswith("sanfastq"):
            fastq_file+='.sanfastq'
        else:
            fastq_file+='.solfastq'
        if s=='.gz':
            fastq_file+='.gz'
        fastq_files.append(fastq_file)
        copy_file_across(path, fastq_file,
                         server_source=server,
                         server_destination=server_destination,
                         overwrite=overwrite)
        
    return fastq_files

def get_link_from_seq_archive(run_element, dest_dir, server_destination=None, overwrite=False):
    """Find file locally and assume that the local mounting is the same remotely.
    creates link to the file in seqarchive and return link name"""
    server_and_paths=find_files_in_seq_archive(run_element)
    run_element_id=run_element.id
    single_end=run_element.run.is_single_end()
    fastq_files=[]
    fastq_files_tmp=[]
    if single_end:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id))
    else:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_1'))
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_2'))
        
    for i in range(len(server_and_paths)):
        server, path = server_and_paths[i]
        fastq_file=fastq_files_tmp[i]
        b,s=os.path.splitext(path)
        
        if b.endswith("sanfastq"):
            fastq_file+='.sanfastq'
        else:
            fastq_file+='.solfastq'
        if s=='.gz':
            fastq_file+='.gz'
        fastq_files.append(fastq_file)
        if server:
            logging.warning("Impossible to link %s from remote server %s. will copy the file instead"%(path, server))
            copy_file_across(path, fastq_file,
                             server_source=server,
                             server_destination=server_destination,
                             overwrite=overwrite)
        else:
            if not server_destination:
                command='ln -fs %s %s'%(path,fastq_file)
            else:
                command='ssh %s "ln -fs %s %s"'%(server_destination,path,fastq_file)
            command_runner.run_command(command)
        
    return fastq_files

def get_files_local_from_seq_archive(run_element, dest_dir, server_destination=None, overwrite=False):
    """This function retrieve fastq file from seqarchive. It returns the original location of the fastq file if it's stored localy.
    It returns a local copy if it's stored somewhere else.
    In both case it returns an array of tuple containing the location and a boolean.
    The boolean is True is the file has been copied and False if it was local."""
    server_and_paths=find_files_in_seq_archive(run_element)
    run_element_id=run_element.id
    single_end=run_element.run.is_single_end()
    fastq_files_and_delete=[]
    fastq_files_tmp=[]
    
    if single_end:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id))
    else:
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_1'))
        fastq_files_tmp.append(os.path.join(dest_dir, run_element_id+'_2'))
        
    for i in range(len(server_and_paths)):
        server, path=server_and_paths[i]
        if (server is None and server_destination is None) or server == server_destination:
            fastq_files_and_delete.append((path, False))
        else:
            fastq_file=fastq_files_tmp[i]
            b,s=os.path.splitext(path)
            if b.endswith("sanfastq"):
                fastq_file+='.sanfastq'
            else:
                fastq_file+='.solfastq'
            if s=='.gz':
                fastq_file+='.gz'
            fastq_files_and_delete.append((fastq_file, True))
            copy_file_across(path, fastq_file,
                             server_source=server,
                             server_destination=server_destination,
                             overwrite=overwrite)
        
    return fastq_files_and_delete


def find_files_in_seq_archive(run_element):
    run=run_element.get_run()
    single_end=run.is_single_end()
    lane=run_element.get_lane_number()
    index_id=run_element.get_index()
    if str(index_id)=='0':
        index_id=None
    server_and_paths=find_seq_archive_file(run.id, lane, index_id, single_end)
    if len(server_and_paths)==0:
        if index_id:
            index_str=' index %s'%index_id
        else:
            index_str=''
        logging.error("Can't find valid path on seqarchive for run %s lane %s%s"%(run.id,lane, index_str))
        
    return server_and_paths

def get_IVC_from_seqarchive(run):
    single_end=run.is_single_end()
    run_date, flowcell_id = run.id.split('_')
    for lane in run.get_lanes():
        lane_number = lane.get_lane_number()
        index_id=lane.get_index()
        server_and_paths=find_seq_archive_file(run.id, lane_number, index_id, single_end)
        if server_and_paths:
            break
    if server_and_paths:
        server, path = server_and_paths[0]
        run_dir = os.path.dirname(path)
        
        IVC_zip_file = os.path.join(run_dir,'%s*.zip'%run_date)
        if server:
            command = 'ssh %s "ls %s"'%(server, IVC_zip_file)
        else:
            command = 'ls %s'%(IVC_zip_file)
        logging.debug(command)
        stream, process = get_output_stream_from_command(command, logger_name=None)
        paths=[]
        for line in stream:
            paths.append(line.strip())
        if len(paths)>0:
            return paths[0]
        else:
            return None

    

def sol_fastq_2_sang_fastq(solexa_fastq_file, sanger_fastq_file, overwrite=False):
    if not os.path.exists(sanger_fastq_file) or overwrite:
        try:
            pipeline_param=utils_param.get_pipeline_parameters()
            maq_dir=pipeline_param.get_maq_dir()
            fq_all2std=os.path.join(maq_dir,'scripts','fq_all2std.pl')
        except Config_file_error, e:
            logging.warning("You'll need to have fq_all2std.pl in your path")
            fq_all2std='fq_all2std.pl'
        if solexa_fastq_file.endswith('.gz'):
            command='gunzip -c %s | perl %s sol2std2 > %s'%(solexa_fastq_file, fq_all2std, sanger_fastq_file)
        else:
            command='cat %s | perl %s sol2std2 > %s'%(solexa_fastq_file, fq_all2std, sanger_fastq_file)
        return_code = command_runner.run_command(command)
        return return_code
    else:
        logging.warning('%s exist use force to overwrite'%sanger_fastq_file)
        return 1
    
def get_all_data_from_seqarchive(all_projects_folder, project_id, link=False):
    #load the information from the wiki
    project=get_wiki_project(project_id)
    for sample in project.get_samples():
        if sample.has_run_element():
            for run_element in sample.get_run_elements():
                if run_element.is_usable():
                    get_data_from_seqarchive(all_projects_folder, project_id, sample.id, run_element.id, link=link)
                else:
                    logging.warning('%s is not usable'%(run_element.id))
        else:
            logging.warning('Sample %s has no run element'%(sample.id))
    

def main():
    #initialize the logging
    utils_logging.init_logging(logging.INFO)
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
        
    if options.debug:
        utils_logging.init_logging(logging.DEBUG)
    if options.projects_dir is None:
        pipeline_places = get_pipeline_places()
        all_projects_folder = pipeline_places.get_illumina_project_dir()
    else:
        all_projects_folder=options.projects_dir
    if not options.print_command:
        command_runner.set_command_to_run_localy()
        
    get_all_data_from_seqarchive(all_projects_folder, options.project_id, link=options.link)


def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog <-i input> <-o outputPath> [-q quality -f]"""
    description = """This script is a template to of a python script that include help and option's checking.
    The requirement and assumption of the script can be described here.
    A link to another documentation can also be added here."""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-p","--project_id",dest="project_id",type="int",
                         help="The project id to analyse.")
    optparser.add_option("-P","--projects_dir",dest="projects_dir",type="string",
                         help="Change the project dir from the default ~/projects.")
    optparser.add_option("-l","--link", dest="link", action="store_true", default=False,
                         help="Link the data instead of copying it")
    optparser.add_option("--print", dest="print_command", action="store_true", default=False,
                         help="print all the command that should be run otherwise")
    optparser.add_option("--debug", dest="debug", action="store_true", default=False,
                         help="Set the logging to output the debug information")
    
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    if not options.project_id:
        logging.error("You must specify an project id with -p.")
        arg_pass=False
    return arg_pass



if __name__=="__main__":
    main()


if __name__=="1__main__":
    utils_logging.init_logging(logging.CRITICAL)
    from wiki_communication.wiki_pages_utils import get_run_page_from_title, get_all_run_page_titles
    for parent_page, run_page_title in get_all_run_page_titles():
        if run_page_title.startswith('10'):
            run = get_run_page_from_title(run_page_title).run
            print run_page_title
            for lane in run.get_lanes(): 
                if lane.has_run_elemt():
                    for run_element in lane.get_run_elemt():
                        print run_element
                        array = find_files_in_seq_archive(run_element)
                        if len(array)>0:
                            print "found"
                        else:
                            print "not found"
                else:
                    print lane
                    array = find_files_in_seq_archive(lane)
                    if len(array)>0:
                        print "found"
                    else:
                        print "not found"

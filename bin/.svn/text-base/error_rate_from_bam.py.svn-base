'''
Created on 21 Jan 2010

@author: tcezard
'''
#!/usr/bin/env python
import sys, logging
from optparse import OptionParser
import re
import SNPs
from utils import utils_logging
from utils.Binning import Distribution_holder
from snps_and_allele_frequency_from_bam import open_input

# this import impose to have the lib in the PYTHONPATH
# you can remove it and change the logging format to '%(asctime)15s: %(levelname)s %(message)s'  


def replace_number_base(match_object):
    s=match_object.group()
    m=re.search('[0-9]+',s)
    if m:
        return s[m.end()+int(m.group()):]
    else: return ''


def error_rate_from_bam(output_file, input_stream=None, bas_qual_threshold=20, map_qual_threshold=10, coverage_threshold=6):
    """
    Pf3D7_09        1       A       A       11      0       6       2       ^(.^&.  HH      (&
    Pf3D7_09        2       A       A       43      0       10      8       ..^).^#.^%.^(.^:.^!,    HHHGHH7H        (&)#%(:!
    Pf3D7_09        3       C       C       49      0       10      10      .......,^%.^*.  HHHCHHAHHH      (&)#%(:!%*
    Pf3D7_09        4       C       C       47      0       9       13      .......,..^".^&.^!.     HHHGHH:HHHHHF   (&)#%(:!%*"&!
    """
    count_line=0
    snps_called=0
    
    real_base_qual_dist=Distribution_holder()
    error_base_qual_dist=Distribution_holder()
    real_output_file=output_file+'.real'
    error_output_file=output_file+'.error'
    deleted_bases=[]
    insterted_bases=[]
    iupac_alphabet=SNPs.get_iupac_alphabet()
    if input_stream is None:
        input_stream=sys.stdin
    if input_stream is not None:
        for line in input_stream:
            count_line+=1
            if count_line%100000==0:
                print count_line, snps_called
            ATCG={'A':0,'T':0,'C':0,'G':0,'N':0}
            ATCG_filtered={'A':0,'T':0,'C':0,'G':0,'N':0}
            ATCG_list_qual={'A':[],'T':[],'C':[],'G':[],'N':[]}
            
            sp_line = line.strip().split()
            ## do not process line specifying the deletion
            if sp_line[2]=='*':
                continue
            ##remove the insertion
            bases=re.sub('\+[0-9]+['+iupac_alphabet+']+',replace_number_base,sp_line[-3])
            ##remove the deletion 
            bases=re.sub('\-[0-9]+['+iupac_alphabet+']+',replace_number_base,bases)
            ##remove weird character for start and end of the read
            bases=re.sub('\^.','',bases)
            bases=re.sub('\$','',bases)
            sp_bases=re.findall('['+iupac_alphabet+'.,*]', bases) # sp_line[8] is the bases
            if len(sp_bases)==len(sp_line[-2]) and len(sp_bases)==len(sp_line[-1]):
                for i, base in enumerate(sp_bases):
                    if base=='.' or base==',':
                        base=sp_line[2]
                    if base not in ['A','T','C','G', 'a', 'c', 'g', 't']:
                        base='N'
                    bas_qual=ord(sp_line[-2][i])-33
                    map_qual=ord(sp_line[-1][i])-33
                    ATCG_list_qual[base.upper()].append(bas_qual)
                    if bas_qual>=bas_qual_threshold and map_qual>=map_qual_threshold:
                        if base.upper() in ATCG.keys():
                            ATCG[base.upper()]+=1
                    else:
                        if base.upper() in ATCG.keys():
                            ATCG_filtered[base.upper()]+=1
            else:
                print 'problem in line %s'%line
                print '%s (%s) and %s (%s) and %s (%s) have different length'%(''.join(sp_bases), len(sp_bases) ,sp_line[-2],
                                                                               len(sp_line[-2]), sp_line[-1], len(sp_line[-1]))
                continue
            ##Calculate overall coverage
            coverage=ATCG['A']+ATCG['C']+ATCG['G']+ATCG['T']+ATCG['N']
            coverage_filtered=ATCG_filtered['A']+ATCG_filtered['C']+ATCG_filtered['G']+ATCG_filtered['T']+ATCG_filtered['N']
            
            ## Get the most frequent base
            sorted_list=sorted(ATCG, key=lambda x: ATCG[x], reverse=True)
            ref_base=SNPs.get_nt_array_from_IUPAC(sp_line[2].upper())
            snp_base=None
            
            if coverage>=coverage_threshold:
                i=0
                while sorted_list[i] not in ref_base:
                    i+=1
                snp_base=sorted_list[i]
                if ATCG[snp_base]<float(coverage)/3:
                    snp_base=None
                if float(coverage_filtered)/float(sp_line[3])>=0.5:
                    snp_base=None
                if snp_base=='N':
                    snp_base=None
            if snp_base:
                first_base_prop=ATCG[sorted_list[0]]
                second_base_prop=ATCG[sorted_list[1]]
                if float(second_base_prop)/(first_base_prop+second_base_prop)>0.3:
                    real_base=[sorted_list[0],sorted_list[1]]
                else:
                    real_base=[sorted_list[0]]
            else:
                real_base=ref_base
                if not ref_base=='N':
                    real_base.append('N')
            
            
            for base in real_base:
                for base_qual in ATCG_list_qual.pop(base):
                    real_base_qual_dist.add_value(base_qual)
            for base in ATCG_list_qual.keys():
                    
                for base_qual in ATCG_list_qual.get(base):
                    error_base_qual_dist.add_value(base_qual)
        
        real_base_qual_dist.print_dist(real_output_file)
        error_base_qual_dist.print_dist(error_output_file)
        input_stream.close()

            
def main():
    #initialise the logging
    utils_logging.init_logging()
    #Setup options
    optparser=_prepare_optparser()
    (options,dummy) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    input_stream=open_input(options.input_file, options.genome_file)
    error_rate_from_bam(options.output_file,
                        input_stream=input_stream,
                        bas_qual_threshold=options.base_qual,
                        map_qual_threshold=options.map_qual)


def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog """
    description = """"""
    
    prog_version='0'
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-i","--input",dest="input_file",type="string",
                         help="Path to a file where the input data are located. Default: %default")
    optparser.add_option("-o","--output",dest="output_file",type="string",
                         help="Path to a file where the results will be output. Default: %default")
    optparser.add_option("-m","--map_qual",dest="map_qual",type="int",default=30,
                         help="The mapping quality threshold used select the reads. Default: %default")
    optparser.add_option('-b',"--base_qual",dest="base_qual",type="int",default=20,
                         help="The base quality threshold used select a base. Default: %default")
    optparser.add_option("-l","--list_position",dest="list_position",type="string",
                         help="Path to a file list of position is. Default: %default")
    optparser.add_option("-g","--genome_file",dest="genome_file",type="string",
                         help="Path to a fasta file containing the genome. Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    # Test output_file
    if not options.output_file:
        logging.error("You must specify and output file.")
        arg_pass=False
    return arg_pass



if __name__=="__main__":
    main()

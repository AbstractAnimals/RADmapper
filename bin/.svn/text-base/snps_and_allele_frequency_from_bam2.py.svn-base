'''
Created on 21 Jan 2010

@author: tcezard
'''
#!/usr/bin/env python
import  sys, logging
from optparse import OptionParser
import re
import SNPs
from utils import utils_logging, get_mpileup_from_bam

def get_mpileup_from_bam(bam_file, genome_file=None, samtools_bin=None, options=''):
    if samtools_bin==None:
        try:
            pipeline_parm=utils_param.get_pipeline_parameters()
            samtools_bin=os.path.join(pipeline_parm.get_samtools_dir(),'samtools')
        except Config_file_error, e:
            logging.warning("Can't find the configuration file you'll need to have samtools in you path.")
            samtools_bin='samtools'
    if bam_file=='PIPE':
        bam_file='-'
    if genome_file:
        command = '%s mpileup -f %s %s %s'%(samtools_bin, genome_file, bam_file, options)
    else:
        command = '%s mpileup %s %s'%(samtools_bin, bam_file, options)
    logging.debug(command)
    stream, process = utils_commands.get_output_stream_from_command(command)
    return stream

def replace_number_base(match_object):
    s=match_object.group()
    m=re.search('[0-9]+',s)
    if m:
        return s[m.end()+int(m.group()):]
    else: return ''


def get_base_frequency_from_line(line, bas_qual_threshold, map_qual_threshold, test_mapping_qual=True):
    ATCG={'A':0,'T':0,'C':0,'G':0}
    ATCG_filtered={'A':0,'T':0,'C':0,'G':0}
    
    sp_line = line.strip().split()
    ## do not process line specifying the deletion
    if sp_line[2]=='*':
        return 
    ##remove the insertion
    iupac_alphabet=SNPs.get_iupac_alphabet()
    bases=re.sub('\+[0-9]+['+iupac_alphabet+']+',replace_number_base,sp_line[4])
    ##remove the deletion 
    bases=re.sub('\-[0-9]+['+iupac_alphabet+']+',replace_number_base,bases)
    ##remove weird character for start and end of the read
    bases=re.sub('\^.','',bases)
    bases=re.sub('\$','',bases)
    sp_bases=re.findall('['+iupac_alphabet+'.,*><]', bases) # sp_line[8] is the bases
    if len(sp_line)<=6:
        test_mapping_qual=False
    if len(sp_bases)==len(sp_line[5]) and (not test_mapping_qual or len(sp_bases)==len(sp_line[6])):
        
        for i, base in enumerate(sp_bases):
            bas_qual=ord(sp_line[5][i])-33
            if test_mapping_qual:
                map_qual=ord(sp_line[6][i])-33
            else:
                map_qual=40
            if bas_qual>=bas_qual_threshold and map_qual>=map_qual_threshold:
                if base=='.' or base==',':
                    base=sp_line[2]
                if base.upper() in ATCG.keys():
                    ATCG[base.upper()]+=1
            else:
                if base=='.' or base==',':
                    base=sp_line[2]
                if base.upper() in ATCG.keys():
                    ATCG_filtered[base.upper()]+=1
    else:
        print 'problem in line %s'%line
        print '%s (%s) and %s (%s) and %s (%s) have different length'%(''.join(sp_bases), len(sp_bases) ,sp_line[-2],
                                                                       len(sp_line[-2]), sp_line[-1], len(sp_line[-1]))
        return None
    return ATCG,ATCG_filtered


def snps_and_allele_frequency_from_bam(output_file, input_stream=None, bas_qual_threshold=20, map_qual_threshold=10,
                                       coverage_threshold=6, coverage_prop=0.3, prop_hom=0.8, frequencies=False):
    """
    Pf3D7_09        1       A       A       11      0       6       2       ^(.^&.  HH      (&
    Pf3D7_09        2       A       A       43      0       10      8       ..^).^#.^%.^(.^:.^!,    HHHGHH7H        (&)#%(:!
    Pf3D7_09        3       C       C       49      0       10      10      .......,^%.^*.  HHHCHHAHHH      (&)#%(:!%*
    Pf3D7_09        4       C       C       47      0       9       13      .......,..^".^&.^!.     HHHGHH:HHHHHF   (&)#%(:!%*"&!
    """
    
    count_line=0
    snps_called=0
    if input_stream is None:
        input_stream=sys.stdin
    if input_stream is not None:
        open_output=utils_logging.open_output_file(output_file, pipe=True)
        for line in input_stream:
            count_line+=1
            if count_line%100000==0:
                print count_line, snps_called
            sp_line=line.strip().split()
            info=get_base_frequency_from_line(line, bas_qual_threshold, map_qual_threshold)
            if info:
                ATCG,ATCG_filtered=info
            else:
                ATCG={'A':0,'T':0,'C':0,'G':0}
                ATCG_filtered={'A':0,'T':0,'C':0,'G':0}
            
            ##Calculate overall coverage
            coverage=ATCG['A']+ATCG['C']+ATCG['G']+ATCG['T']
            coverage_filtered=ATCG_filtered['A']+ATCG_filtered['C']+ATCG_filtered['G']+ATCG_filtered['T']
            if coverage<coverage_threshold:
                continue
            
            ## Get the most frequent base
            sorted_list=sorted(ATCG, key=lambda x: ATCG[x], reverse=True)
            
            ref_base=sp_line[2].upper()
            if sorted_list[0]!=ref_base:
                snp_base=sorted_list[0]
            else:
                snp_base=sorted_list[1]
            
            
            if ATCG[snp_base]<float(coverage)*coverage_prop:
                    continue
            if float(coverage_filtered)/float(sp_line[3])>=0.5:
                continue
            
            snps_called+=1
            # call the genotype
            first_base_prop=ATCG[sorted_list[0]]
            second_base_prop=ATCG[sorted_list[1]]
            if float(first_base_prop)/(first_base_prop+second_base_prop)>=prop_hom:
                genotype=sorted_list[0]+sorted_list[0]
            else:
                genotype=sorted_list[0]+sorted_list[1]
             
            output_line=format_base_freq_line(chr=sp_line[0], position=sp_line[1], ref_base=ref_base,
                                  consensus_base=snp_base, genotype=genotype, ATCG=ATCG,
                                  ATCG_filtered=ATCG_filtered, coverage=coverage, frequencies=frequencies)
            open_output.write('%s\n'%(output_line))
        input_stream.close()
        open_output.close()



def format_base_freq_line(chr, position, ref_base, consensus_base, genotype, ATCG, ATCG_filtered, coverage, frequencies=False):
    out=[]
    out.append(chr)
    out.append('%s'%position)
    out.append(ref_base)
    out.append(consensus_base)
    out.append(genotype)
    out.append('%s'%(coverage))
    if frequencies:
        ##Calculate frequency of each base
        ATGC_freq={'A':0,'T':0,'C':0,'G':0}
        if coverage>0:
            for key in ATCG:
                ATGC_freq[key]=ATCG.get(key)/float(coverage)
        
        out.append('A:%.2f'%(ATGC_freq['A']))
        out.append('T:%.2f'%(ATGC_freq['T']))
        out.append('C:%.2f'%(ATGC_freq['C']))
        out.append('G:%.2f'%(ATGC_freq['G']))
    else:
        out.append('A:%s:%s'%(ATCG['A'],ATCG_filtered['A']))
        out.append('T:%s:%s'%(ATCG['T'],ATCG_filtered['T']))
        out.append('C:%s:%s'%(ATCG['C'],ATCG_filtered['C']))
        out.append('G:%s:%s'%(ATCG['G'],ATCG_filtered['G']))
    return '\t'.join(out)


def coverage_from_bam_and_list_pos(output_file, input_file, genome_file, list_position=None, bas_qual_threshold=20,
                                   map_qual_threshold=10, coverage_threshold=6, coverage_prop=0.3, prop_hom=0.8, frequencies=False):
    """
    Pf3D7_09        1       A       A       11      0       6       2       ^(.^&.  HH      (&
    Pf3D7_09        2       A       A       43      0       10      8       ..^).^#.^%.^(.^:.^!,    HHHGHH7H        (&)#%(:!
    Pf3D7_09        3       C       C       49      0       10      10      .......,^%.^*.  HHHCHHAHHH      (&)#%(:!%*
    Pf3D7_09        4       C       C       47      0       9       13      .......,..^".^&.^!.     HHHGHH:HHHHHF   (&)#%(:!%*"&!
"""
    if list_position is None:
        logging.critical('no list of position file specified')
        return 
    
    count_line=0
    snps_called=0
    all_positionsloaded={}
    open_position=utils_logging.open_input_file(list_position)
    for line in open_position:
        sp_line=line.strip().split()
        if len(sp_line)<2:
            sp_line=line.strip().split(':')
        all_positionsloaded['%s-%s'%(sp_line[0],sp_line[1])]=1
    logging.info('%s positions loaded'%len(all_positionsloaded))
    
    if input_file.endswith('.bam') :
        if genome_file:
            input_stream = get_mpileup_from_bam(input_file, genome_file, options='-s -l %s'%list_position)
        else:
            return None
    else:
        input_stream = utils_logging.open_input_file(input_file)
    
    
    if input_stream is not None:
        open_output=open(output_file,'w')
        for line in input_stream:
            count_line+=1
            sp_line = line.strip().split()
            if not all_positionsloaded.has_key('%s-%s'%(sp_line[0],sp_line[1])):
                continue
            else:
                all_positionsloaded.pop('%s-%s'%(sp_line[0],sp_line[1]))
            
            info=get_base_frequency_from_line(line, bas_qual_threshold, map_qual_threshold)
            if info:
                ATCG,ATCG_filtered=info
            else:
                ATCG={'A':0,'T':0,'C':0,'G':0}
                ATCG_filtered={'A':0,'T':0,'C':0,'G':0}
            
            ##Calculate overall coverage
            coverage=ATCG['A']+ATCG['C']+ATCG['G']+ATCG['T']
            #if coverage<coverage_threshold:
            #    continue
            
            ## Get the most frequent base
            sorted_list=sorted(ATCG, key=lambda x: ATCG[x], reverse=True)
            
            if sorted_list[0]!=sp_line[2].upper():
                snp_base=sorted_list[0]
            else:
                snp_base=sorted_list[1]
            
            #if ATCG[snp_base]<float(coverage)/3:
            #    continue
            #if float(filtered)/float(sp_line[3])>=0.5:
            #    continue
            snps_called+=1
            first_base_prop=ATCG[sorted_list[0]]
            second_base_prop=ATCG[sorted_list[1]]
            second_base_prop=ATCG[sorted_list[1]]
            if first_base_prop+second_base_prop>0:
                if float(first_base_prop)/(first_base_prop+second_base_prop)>=prop_hom:
                    genotype=sorted_list[0]+sorted_list[0]
                else:
                    genotype=sorted_list[0]+sorted_list[1]
            else:
                genotype='XX'
            output_line=format_base_freq_line(chr=sp_line[0], position=sp_line[1], ref_base=sp_line[2].upper(),
                                  consensus_base=snp_base,genotype=genotype, ATCG=ATCG, ATCG_filtered=ATCG_filtered,
                                  coverage=coverage, frequencies=frequencies)
            open_output.write('%s\n'%(output_line))
            if snps_called%10000==0:
                print count_line, snps_called
        input_stream.close()
        open_output.close()


def open_input(input_file, genome_file):
    if input_file.endswith('.bam') :
        if genome_file:
            input_stream=get_mpileup_from_bam(input_file, genome_file, options='-s')
        else:
            return None
    else:
        input_stream=utils_logging.open_input_file(input_file)
    return input_stream


def main():
    #initialise the logging
    utils_logging.init_logging(logging.INFO)
    #Setup options
    optparser=_prepare_optparser()
    (options,dummy) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    
    if options.list_position is not None:
        coverage_from_bam_and_list_pos(options.output_file,
                                       input_file=options.input_file,
                                       genome_file=options.genome_file,
                                       list_position=options.list_position,
                                       bas_qual_threshold=options.base_qual,
                                       map_qual_threshold=options.map_qual,
                                       coverage_threshold=options.coverage,
                                       prop_hom=options.prop_hom,
                                       frequencies=options.output_freq)
    else:
        input_stream=open_input(options.input_file, options.genome_file)
        snps_and_allele_frequency_from_bam(options.output_file,
                                           input_stream=input_stream,
                          bas_qual_threshold=options.base_qual,
                          map_qual_threshold=options.map_qual,
                          coverage_threshold=options.coverage,
                          prop_hom=options.prop_hom,
                          frequencies=options.output_freq)
        

def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog """
    description = """"""
    
    prog_version='0'
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-i","--input",dest="input_file",type="string",
                         help="Path to a file where the input data are located. Default: %default")
    optparser.add_option("-o","--output",dest="output_file",type="string",
                         help="Path to a file where the results will be output. Default: %default")
    optparser.add_option("-m","--map_qual",dest="map_qual",type="int",default=30,
                         help="The mapping quality threshold used select the reads. Default: %default")
    optparser.add_option('-b',"--base_qual",dest="base_qual",type="int",default=20,
                         help="The base quality threshold used select a base. Default: %default")
    optparser.add_option('-c',"--coverage",dest="coverage",type="int",default=6,
                         help="Coverage threshold required to call a snp. Default: %default")
    optparser.add_option('-p',"--coverage_prop",dest="coverage_prop",type="float",default=0.3,
                         help="Proportion of snps base to . Default: %default")
    optparser.add_option('-t',"--prop_hom",dest="prop_hom",type="float",default=0.8,
                         help="Proportion of the most present base call this position homozygous. Default: %default")
    optparser.add_option("-l","--list_position",dest="list_position",type="string",
                         help="Path to a file list of position is. Default: %default")
    optparser.add_option("-g","--genome_file",dest="genome_file",type="string",
                         help="Path to a fasta file containing the genome. Default: %default")
    optparser.add_option("-q","--output_freq",dest="output_freq",action="store_true",
                         help="output the base frequencies instead of the base number. Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    
    # Test output_file
    if not options.output_file:
        logging.error("You must specify and output file.")
        arg_pass=False
    return arg_pass


if __name__=="__main__":
    main()

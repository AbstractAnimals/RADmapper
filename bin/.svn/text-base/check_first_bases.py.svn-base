'''
Created on 23 Apr 2010

@author: tcezard
'''
from HTSeq import FastqReader
from HTSeq import SequenceWithQualities
from HTSeq import Sequence
from utils import utils_logging
import logging
from optparse import OptionParser
import sys
import os
import gzip
from utils.utils_param import check_input_file


samples=['6991','7219','7636','7902']
barcodes=[Sequence('AACTGCT'),Sequence('AACACGT'),Sequence('AACGTAT'),Sequence('AAGAGTT')]

barcodes={Sequence('ACTGC'):'GP-PE-001',
Sequence('ACACGT'):'GP-PE-002',    
Sequence('ACGTAT'):'GP-PE-003',    
Sequence('AGAGTT'):'GP-PE-004',    
Sequence('ATATCT'):'GP-PE-005',    
Sequence('CGATAT'):'GP-PE-006',    
Sequence('GAGATT'):'GP-PE-007',    
Sequence('GTACAT'):'GP-PE-008',    
Sequence('GTGTGT'):'GP-PE-009',    
Sequence('TAGCAT'):'GP-PE-010',    
Sequence('TCAGAT'):'GP-PE-011',    
Sequence('TCGAGT'):'GP-PE-012'}

#Adtapater sequence 5'-->3'
# 1: GCAGT AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG
# 2: CGTGT AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG
# 3: TACGT AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG
#10: TGCTA AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG
#11: TCTGA AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG
#13: ACACTCTTTCCCTACACGACGCTCTTCCGATCT ACTGct
#14: ACACTCTTTCCCTACACGACGCTCTTCCGATCT ACACgt
#19: ACACTCTTTCCCTACACGACGCTCTTCCGATCT GAGAtt



def get_fastq_record_from_file(fastq_name,fastq_reader, fastq_store):
    count_read_fastq2=0
    if fastq_name.endswith('/1') or fastq_name.endswith('/2'):
        fastq_name=fastq_name[:-2]
    fastq_record2=fastq_store.pop(fastq_name,None)
    if fastq_record2 is None:
        for fastq_record2 in fastq_reader:
            count_read_fastq2+=1
            if count_read_fastq2%10==0:
                break
            fastq_name2=fastq_record2.name
            if fastq_name2.endswith('/1') or fastq_name2.endswith('/2'):
                fastq_name2=fastq_name2[:-2]
            if fastq_name2==fastq_name:
                break
            else:
                fastq_store[fastq_record2.name]=fastq_record2
    return fastq_record2

def trim_barcodes(barcodes, fastq_record):
    """barcode should be completely included in the sequence so trim only if it's found."""
    found=None
    for barcode in barcodes.keys():
        fastq_new_seq=fastq_record.trim_left_end(barcode, 2/6)
        if len(fastq_new_seq)==len(fastq_record)-len(barcode):
            if found:
                print 'ERROR: found more than one barcode in %s'%fastq_new_seq
                found=None
                break
            found=(barcodes.get(barcode),fastq_new_seq)
    return found

def trim_adapter(adapters,  fastq_record, nb_base_thr=5):
    """adapters can be partially included in the sequence so trim only if it's found on more than N base(s)."""
    found=None
    for i in range(len(adapters)):
        fastq_new_seq=fastq_record.trim_left_end(adapters[i], 1/6)
        if len(fastq_record)-len(fastq_new_seq) >= nb_base_thr:
            if found:
                print 'ERROR: found more than one barcode in %s'%fastq_new_seq
                found=None
                break
            found=fastq_new_seq
    return found

def check_first_bases(input_file1, input_file2, output_file_template1, output_file_template2):
    reader1 = FastqReader(input_file1, 'solexa')
    reader2 = FastqReader(utils_logging.open_input_file(input_file2, pipe=False), 'solexa')
    fastq_files1={}
    fastq_files2={}
    sample_count={}
    if input_file1.endswith('.gz'):
        onpen_funct=gzip.open
    else:
        onpen_funct=open
    for barcode in barcodes.values():
        fastq_files1[barcode]=onpen_funct(output_file_template1%barcode,'w')
        fastq_files2[barcode]=onpen_funct(output_file_template2%barcode,'w')
        sample_count[barcode]=0
    fastq_files1['unassigned']=onpen_funct(output_file_template1%'unassigned','w')
    fastq_files2['unassigned']=onpen_funct(output_file_template2%'unassigned','w')
    count_sequence=0
    read2_store={}
    well_placed_reads=0
    disagreeing_reads=0
    read1_adapter_only=0
    read2_adapter_only=0
    unassigned=0
    for fastq_record in reader1:
        count_sequence+=1
        found1=None
        found2=None
        if count_sequence%1000000==0:
            print count_sequence, len(read2_store), well_placed_reads, disagreeing_reads, read1_adapter_only, read2_adapter_only, unassigned
        
        found1=trim_barcodes(barcodes, fastq_record)
        
        fastq_record2=get_fastq_record_from_file(fastq_record.name, reader2, read2_store)
        if fastq_record2 is None:
            print 'ERROR %s read was not found'%(fastq_record.name)
            continue
        found2=trim_barcodes(barcodes, fastq_record2)
        if found1 and found2:
            (sample1,fastq_new_seq1)=found1
            (sample2,fastq_new_seq2)=found2
            fastq_new_seq1.name=fastq_record.name
            fastq_new_seq2.name=fastq_record2.name
            if sample1==sample2:
                fastq_new_seq1.write_to_fastq_file(fastq_files1[sample1])
                fastq_new_seq2.write_to_fastq_file(fastq_files2[sample2])
                well_placed_reads+=1
                sample_count[sample1]+=1
            else:
                #two different barcode from the same reads
                #very unlikely so do not use
                fastq_record.write_to_fastq_file(fastq_files1['unassigned'])
                fastq_record2.write_to_fastq_file(fastq_files2['unassigned'])
                disagreeing_reads+=1
        elif found1 and not found2:
            (sample1, fastq_new_seq1)=found1
            fastq_new_seq1.name=fastq_record.name
            fastq_new_seq1.write_to_fastq_file(fastq_files1[sample1])
            fastq_new_seq2=SequenceWithQualities(fastq_record2.seq[6:],fastq_record2.name,fastq_record2.qualstr[6:])
            fastq_new_seq2.write_to_fastq_file(fastq_files2[sample1])
            read1_adapter_only+=1
            sample_count[sample1]+=1
        elif not found1 and found2:
            fastq_record.write_to_fastq_file(fastq_files1['unassigned'])
            fastq_record2.write_to_fastq_file(fastq_files2['unassigned'])
            read2_adapter_only+=1
        else:
            fastq_record.write_to_fastq_file(fastq_files1['unassigned'])
            fastq_record2.write_to_fastq_file(fastq_files2['unassigned'])
            unassigned+=1
        
    for barcode in barcodes.values():
        fastq_files1[barcode].close()
        fastq_files2[barcode].close()
        
    sum=well_placed_reads+disagreeing_reads+read1_adapter_only+read2_adapter_only+unassigned
    print '%s (%.2f%%) well placed reads'%(well_placed_reads, float(well_placed_reads)/sum*100)
    print '%s (%.2f%%) disagreeing reads'%(disagreeing_reads, float(disagreeing_reads)/sum*100)
    print '%s (%.2f%%) adapter found on read1 only'%(read1_adapter_only, float(read1_adapter_only)/sum*100)
    print '%s (%.2f%%) adapter found on read2 only'%(read2_adapter_only, float(read2_adapter_only)/sum*100)
    print '%s (%.2f%%) unassigned'%(unassigned, float(unassigned)/sum)
    for barcode in barcodes.values():
        print '%s (%.2f%%) placed for %s'%(sample_count.get(barcode),
                                           float(sample_count.get(barcode))/(well_placed_reads+read1_adapter_only)*100,
                                           barcode)

            
def main():
    #initialise the logging
    utils_logging.init_logging(logging.INFO)
    #Setup options
    optparser=_prepare_optparser()
    (options,dummy) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    base,ext=os.path.splitext(options.first_read)
    if ext=='.gz':
        base,ext2=os.path.splitext(base)
        output_file_template1=base[:-2]+'_%s'+base[-2:]+ext2+ext
    else:
        base,ext2=os.path.splitext(base)
        output_file_template1=base[:-2]+'_%s'+base[-2:]+ext
    base,ext=os.path.splitext(options.second_read)
    if ext=='.gz':
        base,ext2=os.path.splitext(base)
        output_file_template2=base[:-2]+'_%s'+base[-2:]+ext2+ext
    else:
        base,ext2=os.path.splitext(base)
        output_file_template2=base[:-2]+'_%s'+base[-2:]+ext
            
    check_first_bases(options.first_read, options.second_read, output_file_template1, output_file_template2)

def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog -1 fastq_file -2 fastq_file"""
    description = """"""
    
    prog_version='0'
    optparser = OptionParser(version=prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    optparser.add_option("-1", "--first_read",dest="first_read",type="string",
                         help="The first read of a pair. Default: %default")
    optparser.add_option("-2", "--second_read",dest="second_read",type="string",
                         help="The second read of a pair. Default: %default")
    
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    arg_pass = arg_pass and check_input_file(options.first_read, pipe_allowed=False)
    arg_pass = arg_pass and check_input_file(options.second_read, pipe_allowed=False)
    return arg_pass

if __name__=='__main__':
    main()
    

if __name__=="1__main__":
    file1='/home/tcezard/projects/solid_trial_ecoli/illumina_e_coli/s_8_1_sequence.txt.gz'
    output_file_template1='/home/tcezard/projects/solid_trial_ecoli/illumina_e_coli/s_8_1_sequence_%s.fastq'
    file2='/home/tcezard/projects/solid_trial_ecoli/illumina_e_coli/s_8_2_sequence.txt.gz'
    output_file_template2='/home/tcezard/projects/solid_trial_ecoli/illumina_e_coli/s_8_2_sequence_%s.fastq'
    
    check_first_bases(file1,file2, output_file_template1, output_file_template2)



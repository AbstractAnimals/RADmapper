'''
Created on 26 Jul 2010

@author: tcezard
'''
import glob
from pipeline_directory_structure import create_directory_structure
import os
from utils import utils_param, utils_logging
import logging
import command_runner
import sys
from optparse import OptionParser
import utils
from utils.utils_commands import shellize_file_name,\
    get_output_stream_from_command
from wiki_communication import get_wiki_project
from utils.parameters import Config_file_error


def parse_header(all_headers, bam_file):
    command ="samtools view -H %s "%bam_file
    stream,process = get_output_stream_from_command(command)

    for line in stream:
        sp_line=line.strip().split()
        if sp_line[0]=='@HD':
            continue
        else:
            if not all_headers.has_key(sp_line[0]):
                all_headers[sp_line[0]]={}
            headers = all_headers.get(sp_line[0])
            headers[sp_line[1]]=line.strip()
    return all_headers

def merge_many_small_bam_files(all_bam_files):
    
    #Create the header
    header_start = "@HD\t@VN:1.0\tGO:none\tSO:unsorted"
    all_headers={}
    for bam_file in all_bam_files:
        print "parse %s"%bam_file
        all_headers = parse_header(all_headers,bam_file)
    output_headers = "all_headers_tmp.sam"
    print "output %s"%output_headers
    open_output_headers=utils_logging.open_output_file(output_headers)
    #order=["@SQ","@RG","@PG","@CO"]
    order=["@SQ","@RG"]
    open_output_headers.write(header_start+'\n')
    for header_element in order:
        if all_headers.has_key(header_element):
            header_section = all_headers.get(header_element)
            all_header_keys = header_section.keys()
            all_header_keys.sort()
            for header_key in all_header_keys:
                line = header_section.get(header_key)
                if line:
                    open_output_headers.write(line+"\n")
    open_output_headers.close()
    #Merge the reads
    all_reads_sorted="all_reads_sorted"
    command_array=[]
    command_array.append("bash -c 'cat %s "%output_headers)
    for bam_file in all_bam_files:
        command_array.append(" <(samtools view %s)"%bam_file)
    command_array.append(" | samtools view -bS - | samtools sort - %s '"%all_reads_sorted)
    
    print ''.join(command_array)


def main():
    #initialize the logging
    utils_logging.init_logging(logging.INFO)
    #Setup options
    optparser=_prepare_optparser()
    (options,args) = optparser.parse_args()
    #verify options
    arg_pass=_verifyOption(options)
    if not arg_pass:
        logging.warning(optparser.get_usage())
        logging.critical("Non valid arguments: exit")
        sys.exit(1)
    
    all_bam_files=args
    merge_many_small_bam_files(all_bam_files)
        
def _prepare_optparser():
    """Prepare optparser object. New options will be added in this
    function first.
    """
    usage = """usage: %prog -p <project_id> [-a aligner -s -P project_dir]"""
    description = """This script will merge elements that have been aligned independently into one bam file per sample."""
    
    prog_version=utils.getWtss_version()
    optparser = OptionParser(version="%prog of wtss_pipeline v"+prog_version,description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="show this help message and exit.")
    
    
    optparser.add_option("--print",dest="print_commands",action='store_true',default=False,
                         help="Print the command instead of running them. Default: %default")
    return optparser


def _verifyOption(options):
    """Check if the mandatory option are present in the options objects.
    @return False if any argument is wrong."""
    arg_pass=True
    return arg_pass



if __name__=="__main__":
    main()       